<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NewRobotCode/WPILIBC(v2022.3.1): Reader API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ORION.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NewRobotCode/WPILIBC(v2022.3.1)
   &#160;<span id="projectnumber">v2022.0.0.28</span>
   </div>
   <div id="projectbrief">FRC 2022 Robot Code for Team #7464 - ORION</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__reader.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Reader API</div>  </div>
</div><!--header-->
<div class="contents">

<p>The MPack Reader API contains functions for imperatively reading dynamically typed data from a MessagePack stream.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:gac8b222eb575099fa92f086eeeb8dc83f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gac8b222eb575099fa92f086eeeb8dc83f">MPACK_READER_MINIMUM_BUFFER_SIZE</a>&#160;&#160;&#160;32</td></tr>
<tr class="separator:gac8b222eb575099fa92f086eeeb8dc83f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:gaee791c36a15344b9e57edae160c86615"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a></td></tr>
<tr class="separator:gaee791c36a15344b9e57edae160c86615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97503ca06d41d58c60226b2732661eda"><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga97503ca06d41d58c60226b2732661eda">mpack_reader_fill_t</a>) (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *<a class="el" href="classbuffer.html">buffer</a>, size_t count)</td></tr>
<tr class="separator:ga97503ca06d41d58c60226b2732661eda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6a0b236c7befe9cb959dabce15acd23b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga6a0b236c7befe9cb959dabce15acd23b">mpack_reader_skip_t</a>) (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t count)</td></tr>
<tr class="separator:ga6a0b236c7befe9cb959dabce15acd23b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799a3f21adc8e229c6040ab42d90bef3"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga799a3f21adc8e229c6040ab42d90bef3">mpack_reader_error_t</a>) (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="separator:ga799a3f21adc8e229c6040ab42d90bef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadda6baaccdcf0ad9c5e212be9992cf5b"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gadda6baaccdcf0ad9c5e212be9992cf5b">mpack_reader_teardown_t</a>) (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gadda6baaccdcf0ad9c5e212be9992cf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Lifecycle Functions</h2></td></tr>
<tr class="memitem:ga1d79c00c6c013b879b164c26753b3e83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga1d79c00c6c013b879b164c26753b3e83">mpack_reader_init</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *<a class="el" href="classbuffer.html">buffer</a>, size_t size, size_t count)</td></tr>
<tr class="separator:ga1d79c00c6c013b879b164c26753b3e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga729bf4c0a79516e97a65d2e278f336e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga729bf4c0a79516e97a65d2e278f336e0">mpack_reader_init_error</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="separator:ga729bf4c0a79516e97a65d2e278f336e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18f41d6786155f265769351ef550e331"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga18f41d6786155f265769351ef550e331">mpack_reader_init_data</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, const char *data, size_t count)</td></tr>
<tr class="separator:ga18f41d6786155f265769351ef550e331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf19892a6dd87d86bdd02646528964ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gadf19892a6dd87d86bdd02646528964ff">mpack_reader_init_filename</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, const char *filename)</td></tr>
<tr class="separator:gadf19892a6dd87d86bdd02646528964ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58ae5ed702eec1edc717bb91912d0117"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga58ae5ed702eec1edc717bb91912d0117">mpack_reader_init_file</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, const char *filename)</td></tr>
<tr class="separator:ga58ae5ed702eec1edc717bb91912d0117"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga97127332a566ac5fd7da541cad50bac4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga97127332a566ac5fd7da541cad50bac4">mpack_reader_init_stdfile</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, FILE *stdfile, bool close_when_done)</td></tr>
<tr class="separator:ga97127332a566ac5fd7da541cad50bac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac04666405e21eea6e8819182571f0d20"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gac04666405e21eea6e8819182571f0d20">mpack_reader_destroy</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gac04666405e21eea6e8819182571f0d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf46d5fd103d44d03c412cb7bb52e2d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gabf46d5fd103d44d03c412cb7bb52e2d0">mpack_writer_init</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, char *<a class="el" href="classbuffer.html">buffer</a>, size_t size)</td></tr>
<tr class="separator:gabf46d5fd103d44d03c412cb7bb52e2d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0aa3b265fb5ece9c4cba0f2b1bfbdb53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga0aa3b265fb5ece9c4cba0f2b1bfbdb53">mpack_writer_init_growable</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, char **data, size_t *size)</td></tr>
<tr class="separator:ga0aa3b265fb5ece9c4cba0f2b1bfbdb53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab3c8d9ebe78513a17a38af28f387d169"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gab3c8d9ebe78513a17a38af28f387d169">mpack_writer_init_error</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="separator:gab3c8d9ebe78513a17a38af28f387d169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80c2f57160ec9e0efe02f2b3820a8661"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga80c2f57160ec9e0efe02f2b3820a8661">mpack_writer_init_filename</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *filename)</td></tr>
<tr class="separator:ga80c2f57160ec9e0efe02f2b3820a8661"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15181d2c6766254010359db02f5b036a"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga15181d2c6766254010359db02f5b036a">mpack_writer_init_file</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, const char *filename)</td></tr>
<tr class="separator:ga15181d2c6766254010359db02f5b036a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabe9a212641a4edd010ccdd9ecf888485"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gabe9a212641a4edd010ccdd9ecf888485">mpack_writer_init_stdfile</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer, FILE *stdfile, bool close_when_done)</td></tr>
<tr class="separator:gabe9a212641a4edd010ccdd9ecf888485"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1cf5a2d9b687d94f637a36123ef7cec0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga1cf5a2d9b687d94f637a36123ef7cec0">mpack_writer_destroy</a> (<a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *writer)</td></tr>
<tr class="separator:ga1cf5a2d9b687d94f637a36123ef7cec0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3950ce57f3f125755cc1cefd1f54e149"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga3950ce57f3f125755cc1cefd1f54e149">mpack_reader_init_stack</a>(reader)</td></tr>
<tr class="separator:ga3950ce57f3f125755cc1cefd1f54e149"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Callbacks</h2></td></tr>
<tr class="memitem:ga0b209288e5aa980d3a2ed8aaf7fa72ce"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga0b209288e5aa980d3a2ed8aaf7fa72ce">mpack_reader_set_context</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, void *context)</td></tr>
<tr class="separator:ga0b209288e5aa980d3a2ed8aaf7fa72ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83a8e7c2c40a4d41fc53c6b8d28def54"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga83a8e7c2c40a4d41fc53c6b8d28def54">mpack_reader_context</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:ga83a8e7c2c40a4d41fc53c6b8d28def54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf4eab68e9d1751ff9c6c853d563d9a0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaf4eab68e9d1751ff9c6c853d563d9a0e">mpack_reader_set_fill</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__reader.html#ga97503ca06d41d58c60226b2732661eda">mpack_reader_fill_t</a> fill)</td></tr>
<tr class="separator:gaf4eab68e9d1751ff9c6c853d563d9a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa925114414e77ff809fcaaba399c8162"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaa925114414e77ff809fcaaba399c8162">mpack_reader_set_skip</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__reader.html#ga6a0b236c7befe9cb959dabce15acd23b">mpack_reader_skip_t</a> skip)</td></tr>
<tr class="separator:gaa925114414e77ff809fcaaba399c8162"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa008b64c5a452b251f5b81717da3d404"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaa008b64c5a452b251f5b81717da3d404">mpack_reader_set_error_handler</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__reader.html#ga799a3f21adc8e229c6040ab42d90bef3">mpack_reader_error_t</a> error_fn)</td></tr>
<tr class="separator:gaa008b64c5a452b251f5b81717da3d404"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaefab265bf5fb2867d69948f220570347"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaefab265bf5fb2867d69948f220570347">mpack_reader_set_teardown</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__reader.html#gadda6baaccdcf0ad9c5e212be9992cf5b">mpack_reader_teardown_t</a> teardown)</td></tr>
<tr class="separator:gaefab265bf5fb2867d69948f220570347"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Core Reader Functions</h2></td></tr>
<tr class="memitem:ga8004b57cad188f6d315f5c4d36357272"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga8004b57cad188f6d315f5c4d36357272">mpack_reader_error</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:ga8004b57cad188f6d315f5c4d36357272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5c45c2e0592f16ae671cd509d8d8c512"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga5c45c2e0592f16ae671cd509d8d8c512">mpack_reader_flag_error</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="separator:ga5c45c2e0592f16ae671cd509d8d8c512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga15496dcbb58a2a66dfe97d8778d54274"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga15496dcbb58a2a66dfe97d8778d54274">mpack_reader_flag_if_error</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="separator:ga15496dcbb58a2a66dfe97d8778d54274"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga291a38358bde6992b16edda81f2fcf45"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga291a38358bde6992b16edda81f2fcf45">mpack_reader_remaining</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, const char **data)</td></tr>
<tr class="separator:ga291a38358bde6992b16edda81f2fcf45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga70c00ecaf381e9711f6c1d0fa92f0c2f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga008da69ac6b5582a893f2d2ffd37f4ac">mpack_tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f">mpack_read_tag</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:ga70c00ecaf381e9711f6c1d0fa92f0c2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga397a8d0738b8d68753a470a988b813aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga008da69ac6b5582a893f2d2ffd37f4ac">mpack_tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga397a8d0738b8d68753a470a988b813aa">mpack_peek_tag</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:ga397a8d0738b8d68753a470a988b813aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65cd03cc254315c2e5bfe2a7d9043ee8"><td class="memItemLeft" align="right" valign="top"><a id="ga65cd03cc254315c2e5bfe2a7d9043ee8"></a>
MPACK_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><b>mpack_done_type</b> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__common.html#ga22f03cf1240d5a917e1b3e7be8ab327e">mpack_type_t</a> type)</td></tr>
<tr class="separator:ga65cd03cc254315c2e5bfe2a7d9043ee8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b5b8fd101d63c96b6b89e675c981b78"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga2b5b8fd101d63c96b6b89e675c981b78">mpack_done_array</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:ga2b5b8fd101d63c96b6b89e675c981b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga86165fc780e7adef09f4b45aee54842a"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:ga86165fc780e7adef09f4b45aee54842a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaaad37015e0c53704d9356de06b493de6"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6">mpack_done_str</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gaaad37015e0c53704d9356de06b493de6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4676c4b0761de4f864fd81c347a15a0"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0">mpack_done_bin</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gaa4676c4b0761de4f864fd81c347a15a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga438bb2b85fbbd06cd8f10d5c8079427e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga438bb2b85fbbd06cd8f10d5c8079427e">mpack_discard</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:ga438bb2b85fbbd06cd8f10d5c8079427e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
String and Data Functions</h2></td></tr>
<tr class="memitem:ga0c7e1dd2be56ce3d596326c4463e7229"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga0c7e1dd2be56ce3d596326c4463e7229">mpack_skip_bytes</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t count)</td></tr>
<tr class="separator:ga0c7e1dd2be56ce3d596326c4463e7229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeb91e8d4e2a7b7f6562d8bbb7400275c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c">mpack_read_bytes</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *p, size_t count)</td></tr>
<tr class="separator:gaeb91e8d4e2a7b7f6562d8bbb7400275c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee9d5bd9ec3d123dac575651f0ec2186"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaee9d5bd9ec3d123dac575651f0ec2186">mpack_read_utf8</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *p, size_t byte_count)</td></tr>
<tr class="separator:gaee9d5bd9ec3d123dac575651f0ec2186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga628cbed1d2ffac977fed3b9ef5bf0fea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga628cbed1d2ffac977fed3b9ef5bf0fea">mpack_read_cstr</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *buf, size_t buffer_size, size_t byte_count)</td></tr>
<tr class="separator:ga628cbed1d2ffac977fed3b9ef5bf0fea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad053c4bccda721a25c48d66fa0f211cf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gad053c4bccda721a25c48d66fa0f211cf">mpack_read_utf8_cstr</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *buf, size_t buffer_size, size_t byte_count)</td></tr>
<tr class="separator:gad053c4bccda721a25c48d66fa0f211cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0279f46262ff76e66d7f80def282c53f"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga0279f46262ff76e66d7f80def282c53f">mpack_read_bytes_alloc</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t count)</td></tr>
<tr class="separator:ga0279f46262ff76e66d7f80def282c53f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga654d697da6a0eaf25246adf3ed343572"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572">mpack_read_bytes_inplace</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t count)</td></tr>
<tr class="separator:ga654d697da6a0eaf25246adf3ed343572"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa226c085be65e82ae9d4d1057c24f909"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gaa226c085be65e82ae9d4d1057c24f909">mpack_read_utf8_inplace</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t count)</td></tr>
<tr class="separator:gaa226c085be65e82ae9d4d1057c24f909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac5cd4b489f3c5ffd3b5d114efb58a21f"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__reader.html#gac5cd4b489f3c5ffd3b5d114efb58a21f">mpack_should_read_bytes_inplace</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t count)</td></tr>
<tr class="separator:gac5cd4b489f3c5ffd3b5d114efb58a21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The MPack Reader API contains functions for imperatively reading dynamically typed data from a MessagePack stream. </p>
<p>See docs/reader.md for examples.</p>
<dl class="section note"><dt>Note</dt><dd>If you are not writing code for an embedded device (or otherwise do not need maximum performance with minimal memory usage), you should not use this. You probably want to use the <a class="el" href="group__node.html">Node API</a> instead.</dd></dl>
<p>This forms the basis of the <a class="el" href="group__expect.html">Expect API</a>, which can be used to interpret the stream of elements in expected types and value ranges. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga3950ce57f3f125755cc1cefd1f54e149"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3950ce57f3f125755cc1cefd1f54e149">&#9670;&nbsp;</a></span>mpack_reader_init_stack</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mpack_reader_init_stack</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reader</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an MPack reader using stack space as a buffer. A fill function should be added to the reader to fill the buffer.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#gaf4eab68e9d1751ff9c6c853d563d9a0e">mpack_reader_set_fill</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l04574">4574</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gac8b222eb575099fa92f086eeeb8dc83f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac8b222eb575099fa92f086eeeb8dc83f">&#9670;&nbsp;</a></span>MPACK_READER_MINIMUM_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MPACK_READER_MINIMUM_BUFFER_SIZE&#160;&#160;&#160;32</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The minimum buffer size for a reader with a fill function. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l04386">4386</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga799a3f21adc8e229c6040ab42d90bef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga799a3f21adc8e229c6040ab42d90bef3">&#9670;&nbsp;</a></span>mpack_reader_error_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mpack_reader_error_t) (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An error handler function to be called when an error is flagged on the reader.</p>
<p>The error handler will only be called once on the first error flagged; any subsequent reads and errors are ignored, and the reader is permanently in that error state.</p>
<p>MPack is safe against non-local jumps out of error handler callbacks. This means you are allowed to longjmp or throw an exception (in C++, Objective-C, or with SEH) out of this callback.</p>
<p>Bear in mind when using longjmp that local non-volatile variables that have changed are undefined when setjmp() returns, so you can't put the reader on the stack in the same activation frame as the setjmp without declaring it volatile.</p>
<p>You must still eventually destroy the reader. It is not destroyed automatically when an error is flagged. It is safe to destroy the reader within this error callback, but you will either need to perform a non-local jump, or store something in your context to identify that the reader is destroyed since any future accesses to it cause undefined behavior. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l04456">4456</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga97503ca06d41d58c60226b2732661eda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97503ca06d41d58c60226b2732661eda">&#9670;&nbsp;</a></span>mpack_reader_fill_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* mpack_reader_fill_t) (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *<a class="el" href="classbuffer.html">buffer</a>, size_t count)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The MPack reader's fill function. It should fill the buffer with at least one byte and at most the given <code>count</code>, returning the number of bytes written to the buffer.</p>
<p>In case of error, it should flag an appropriate error on the reader (usually <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4a6581b50527f1c278f852c91bea70f847">mpack_error_io</a>), or simply return zero. If zero is returned, mpack_error_io is raised.</p>
<dl class="section note"><dt>Note</dt><dd>When reading from a stream, you should only copy and return the bytes that are immediately available. It is always safe to return less than the requested count as long as some non-zero number of bytes are read; if more bytes are needed, the read function will simply be called again.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#ga83a8e7c2c40a4d41fc53c6b8d28def54">mpack_reader_context()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l04420">4420</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga6a0b236c7befe9cb959dabce15acd23b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6a0b236c7befe9cb959dabce15acd23b">&#9670;&nbsp;</a></span>mpack_reader_skip_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mpack_reader_skip_t) (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t count)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The MPack reader's skip function. It should discard the given number of bytes from the source (for example by seeking forward.)</p>
<p>In case of error, it should flag an appropriate error on the reader.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#ga83a8e7c2c40a4d41fc53c6b8d28def54">mpack_reader_context()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l04430">4430</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gaee791c36a15344b9e57edae160c86615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee791c36a15344b9e57edae160c86615">&#9670;&nbsp;</a></span>mpack_reader_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> <a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A buffered MessagePack decoder.</p>
<p>The decoder wraps an existing buffer and, optionally, a fill function. This allows efficiently decoding data from existing memory buffers, files, streams, etc.</p>
<p>All read operations are synchronous; they will block until the requested data is fully read, or an error occurs.</p>
<p>This structure is opaque; its fields should not be accessed outside of MPack. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l04401">4401</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gadda6baaccdcf0ad9c5e212be9992cf5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadda6baaccdcf0ad9c5e212be9992cf5b">&#9670;&nbsp;</a></span>mpack_reader_teardown_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mpack_reader_teardown_t) (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A teardown function to be called when the reader is destroyed. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l04461">4461</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga438bb2b85fbbd06cd8f10d5c8079427e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga438bb2b85fbbd06cd8f10d5c8079427e">&#9670;&nbsp;</a></span>mpack_discard()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_discard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads and discards the next object. This will read and discard all contained data as well if it is a compound type. </p>

</div>
</div>
<a id="ga2b5b8fd101d63c96b6b89e675c981b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b5b8fd101d63c96b6b89e675c981b78">&#9670;&nbsp;</a></span>mpack_done_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE void mpack_done_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finishes reading an array.</p>
<p>This will track reads to ensure that the correct number of elements are read. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05078">5078</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gaa4676c4b0761de4f864fd81c347a15a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4676c4b0761de4f864fd81c347a15a0">&#9670;&nbsp;</a></span>mpack_done_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mpack_done_bin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finishes reading a binary data blob.</p>
<p>This will track reads to ensure that the correct number of bytes are read. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05111">5111</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga86165fc780e7adef09f4b45aee54842a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga86165fc780e7adef09f4b45aee54842a">&#9670;&nbsp;</a></span>mpack_done_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mpack_done_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finishes reading a map.</p>
<p>This will track reads to ensure that the correct number of elements are read. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05089">5089</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gaaad37015e0c53704d9356de06b493de6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaaad37015e0c53704d9356de06b493de6">&#9670;&nbsp;</a></span>mpack_done_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">mpack_done_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finishes reading a string.</p>
<p>This will track reads to ensure that the correct number of bytes are read. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05100">5100</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga397a8d0738b8d68753a470a988b813aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga397a8d0738b8d68753a470a988b813aa">&#9670;&nbsp;</a></span>mpack_peek_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga008da69ac6b5582a893f2d2ffd37f4ac">mpack_tag_t</a> mpack_peek_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses the next MessagePack object header (an MPack tag) without advancing the reader.</p>
<p>If an error occurs, the reader is placed in an error state and a nil tag is returned. If the reader is already in an error state, a nil tag is returned.</p>
<dl class="section note"><dt>Note</dt><dd>Maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f">mpack_read_tag()</a> </dd>
<dd>
<a class="el" href="group__reader.html#ga438bb2b85fbbd06cd8f10d5c8079427e">mpack_discard()</a> </dd></dl>

</div>
</div>
<a id="gaeb91e8d4e2a7b7f6562d8bbb7400275c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeb91e8d4e2a7b7f6562d8bbb7400275c">&#9670;&nbsp;</a></span>mpack_read_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_read_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads bytes from a string, binary blob or extension object, copying them into the given buffer.</p>
<p>A str, bin or ext must have been opened by a call to <a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f">mpack_read_tag()</a> which yielded one of these types, or by a call to an expect function such as <a class="el" href="group__expect.html#ga6baba88194988c9f423630052d59f7fd">mpack_expect_str()</a> or <a class="el" href="group__expect.html#gadcf7fc94ae30ed5c3752291a0efd43c5">mpack_expect_bin()</a>.</p>
<p>If an error occurs, the buffer contents are undefined.</p>
<p>This can be called multiple times for a single str, bin or ext to read the data in chunks. The total data read must add up to the size of the object.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader </td></tr>
    <tr><td class="paramname">p</td><td>The buffer in which to copy the bytes </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes to read </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0279f46262ff76e66d7f80def282c53f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0279f46262ff76e66d7f80def282c53f">&#9670;&nbsp;</a></span>mpack_read_bytes_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE char* mpack_read_bytes_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads bytes from a string, binary blob or extension object, allocating storage for them and returning the allocated pointer.</p>
<p>The allocated string must be freed with <a class="el" href="group__config.html#ga298d7c2e4093bcfe361088df9e35956a">MPACK_FREE()</a> (or simply free() if MPack's allocator hasn't been customized.)</p>
<p>Returns NULL if any error occurs, or if count is zero. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l04938">4938</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga654d697da6a0eaf25246adf3ed343572"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga654d697da6a0eaf25246adf3ed343572">&#9670;&nbsp;</a></span>mpack_read_bytes_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* mpack_read_bytes_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads bytes from a string, binary blob or extension object in-place in the buffer. This can be used to avoid copying the data.</p>
<p>A str, bin or ext must have been opened by a call to <a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f">mpack_read_tag()</a> which yielded one of these types, or by a call to an expect function such as <a class="el" href="group__expect.html#ga6baba88194988c9f423630052d59f7fd">mpack_expect_str()</a> or <a class="el" href="group__expect.html#gadcf7fc94ae30ed5c3752291a0efd43c5">mpack_expect_bin()</a>.</p>
<p>If the bytes are from a string, the string is not null-terminated! Use <a class="el" href="group__reader.html#ga628cbed1d2ffac977fed3b9ef5bf0fea">mpack_read_cstr()</a> to copy the string into a buffer and add a null-terminator.</p>
<p>The returned pointer is invalidated on the next read, or when the buffer is destroyed.</p>
<p>The reader will move data around in the buffer if needed to ensure that the pointer can always be returned, so this should only be used if count is very small compared to the buffer size. If you need to check whether a small size is reasonable (for example you intend to handle small and large sizes differently), you can call <a class="el" href="group__reader.html#gac5cd4b489f3c5ffd3b5d114efb58a21f">mpack_should_read_bytes_inplace()</a>.</p>
<p>This can be called multiple times for a single str, bin or ext to read the data in chunks. The total data read must add up to the size of the object.</p>
<p>NULL is returned if the reader is in an error state.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_too_big</td><td>if the requested size is larger than the buffer size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#gac5cd4b489f3c5ffd3b5d114efb58a21f">mpack_should_read_bytes_inplace()</a> </dd></dl>

</div>
</div>
<a id="ga628cbed1d2ffac977fed3b9ef5bf0fea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga628cbed1d2ffac977fed3b9ef5bf0fea">&#9670;&nbsp;</a></span>mpack_read_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_read_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byte_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads bytes from a string, ensures that the string contains no NUL bytes, copies the bytes into the given buffer and adds a null-terminator.</p>
<p>A string must have been opened by a call to <a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f">mpack_read_tag()</a> which yielded a string, or by a call to an expect function such as <a class="el" href="group__expect.html#ga6baba88194988c9f423630052d59f7fd">mpack_expect_str()</a>.</p>
<p>The given byte count must match the size of the string as returned by the tag or expect function. The string will only be copied if the buffer is large enough to store it.</p>
<p>If an error occurs, the buffer will contain an empty string.</p>
<dl class="section note"><dt>Note</dt><dd>If you know the object will be a string before reading it, it is highly recommended to use <a class="el" href="group__expect.html#ga94489d03628c1fb1a3d0ac6971600fe8">mpack_expect_cstr()</a> instead. Alternatively you could use <a class="el" href="group__reader.html#ga397a8d0738b8d68753a470a988b813aa">mpack_peek_tag()</a> and call <a class="el" href="group__expect.html#ga94489d03628c1fb1a3d0ac6971600fe8">mpack_expect_cstr()</a> if it's a string.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_too_big</td><td>if the string plus null-terminator is larger than the given buffer size </td></tr>
    <tr><td class="paramname">mpack_error_type</td><td>if the string contains a null byte.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#ga397a8d0738b8d68753a470a988b813aa">mpack_peek_tag()</a> </dd>
<dd>
<a class="el" href="group__expect.html#ga94489d03628c1fb1a3d0ac6971600fe8">mpack_expect_cstr()</a> </dd>
<dd>
<a class="el" href="group__expect.html#ga62be63032f3c84181eeed4609f0dddb4">mpack_expect_utf8_cstr()</a> </dd></dl>

</div>
</div>
<a id="ga70c00ecaf381e9711f6c1d0fa92f0c2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga70c00ecaf381e9711f6c1d0fa92f0c2f">&#9670;&nbsp;</a></span>mpack_read_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga008da69ac6b5582a893f2d2ffd37f4ac">mpack_tag_t</a> mpack_read_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a MessagePack object header (an MPack tag.)</p>
<p>If an error occurs, the reader is placed in an error state and a nil tag is returned. If the reader is already in an error state, a nil tag is returned.</p>
<p>If the type is compound (i.e. is a map, array, string, binary or extension type), additional reads are required to get the contained data, and the corresponding done function must be called when done.</p>
<dl class="section note"><dt>Note</dt><dd>Maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c">mpack_read_bytes()</a> </dd>
<dd>
<a class="el" href="group__reader.html#ga2b5b8fd101d63c96b6b89e675c981b78">mpack_done_array()</a> </dd>
<dd>
<a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> </dd>
<dd>
<a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6">mpack_done_str()</a> </dd>
<dd>
<a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0">mpack_done_bin()</a> </dd>
<dd>
mpack_done_ext() </dd></dl>

</div>
</div>
<a id="gaee9d5bd9ec3d123dac575651f0ec2186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee9d5bd9ec3d123dac575651f0ec2186">&#9670;&nbsp;</a></span>mpack_read_utf8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_read_utf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byte_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads bytes from a string, ensures that the string is valid UTF-8, and copies the bytes into the given buffer.</p>
<p>A string must have been opened by a call to <a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f">mpack_read_tag()</a> which yielded a string, or by a call to an expect function such as <a class="el" href="group__expect.html#ga6baba88194988c9f423630052d59f7fd">mpack_expect_str()</a>.</p>
<p>The given byte count must match the complete size of the string as returned by the tag or expect function. You must ensure that the buffer fits the data.</p>
<p>This does not accept any UTF-8 variant such as Modified UTF-8, CESU-8 or WTF-8. Only pure UTF-8 is allowed.</p>
<p>If an error occurs, the buffer contents are undefined.</p>
<p>Unlike <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c">mpack_read_bytes()</a>, this cannot be used to read the data in chunks (since this might split a character's UTF-8 bytes, and the reader does not keep track of the UTF-8 decoding state between reads.)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the string contains invalid UTF-8. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad053c4bccda721a25c48d66fa0f211cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad053c4bccda721a25c48d66fa0f211cf">&#9670;&nbsp;</a></span>mpack_read_utf8_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_read_utf8_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>byte_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads bytes from a string, ensures that the string is valid UTF-8 with no NUL bytes, copies the bytes into the given buffer and adds a null-terminator.</p>
<p>A string must have been opened by a call to <a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f">mpack_read_tag()</a> which yielded a string, or by a call to an expect function such as <a class="el" href="group__expect.html#ga6baba88194988c9f423630052d59f7fd">mpack_expect_str()</a>.</p>
<p>The given byte count must match the size of the string as returned by the tag or expect function. The string will only be copied if the buffer is large enough to store it.</p>
<p>This does not accept any UTF-8 variant such as Modified UTF-8, CESU-8 or WTF-8. Only pure UTF-8 is allowed, but without the NUL character, since it cannot be represented in a null-terminated string.</p>
<p>If an error occurs, the buffer will contain an empty string.</p>
<dl class="section note"><dt>Note</dt><dd>If you know the object will be a string before reading it, it is highly recommended to use <a class="el" href="group__expect.html#ga62be63032f3c84181eeed4609f0dddb4">mpack_expect_utf8_cstr()</a> instead. Alternatively you could use <a class="el" href="group__reader.html#ga397a8d0738b8d68753a470a988b813aa">mpack_peek_tag()</a> and call <a class="el" href="group__expect.html#ga62be63032f3c84181eeed4609f0dddb4">mpack_expect_utf8_cstr()</a> if it's a string.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_too_big</td><td>if the string plus null-terminator is larger than the given buffer size </td></tr>
    <tr><td class="paramname">mpack_error_type</td><td>if the string contains invalid UTF-8 or a null byte.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#ga397a8d0738b8d68753a470a988b813aa">mpack_peek_tag()</a> </dd>
<dd>
<a class="el" href="group__expect.html#ga62be63032f3c84181eeed4609f0dddb4">mpack_expect_utf8_cstr()</a> </dd></dl>

</div>
</div>
<a id="gaa226c085be65e82ae9d4d1057c24f909"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa226c085be65e82ae9d4d1057c24f909">&#9670;&nbsp;</a></span>mpack_read_utf8_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* mpack_read_utf8_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads bytes from a string in-place in the buffer and ensures they are valid UTF-8. This can be used to avoid copying the data.</p>
<p>A string must have been opened by a call to <a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f">mpack_read_tag()</a> which yielded a string, or by a call to an expect function such as <a class="el" href="group__expect.html#ga6baba88194988c9f423630052d59f7fd">mpack_expect_str()</a>.</p>
<p>The string is not null-terminated! Use <a class="el" href="group__reader.html#gad053c4bccda721a25c48d66fa0f211cf">mpack_read_utf8_cstr()</a> to copy the string into a buffer and add a null-terminator.</p>
<p>The returned pointer is invalidated on the next read, or when the buffer is destroyed.</p>
<p>The reader will move data around in the buffer if needed to ensure that the pointer can always be returned, so this should only be used if count is very small compared to the buffer size. If you need to check whether a small size is reasonable (for example you intend to handle small and large sizes differently), you can call <a class="el" href="group__reader.html#gac5cd4b489f3c5ffd3b5d114efb58a21f">mpack_should_read_bytes_inplace()</a>.</p>
<p>This does not accept any UTF-8 variant such as Modified UTF-8, CESU-8 or WTF-8. Only pure UTF-8 is allowed.</p>
<p>Unlike <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572">mpack_read_bytes_inplace()</a>, this cannot be used to read the data in chunks (since this might split a character's UTF-8 bytes, and the reader does not keep track of the UTF-8 decoding state between reads.)</p>
<p>NULL is returned if the reader is in an error state.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the string contains invalid UTF-8 </td></tr>
    <tr><td class="paramname">mpack_error_too_big</td><td>if the requested size is larger than the buffer size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#gac5cd4b489f3c5ffd3b5d114efb58a21f">mpack_should_read_bytes_inplace()</a> </dd></dl>

</div>
</div>
<a id="ga83a8e7c2c40a4d41fc53c6b8d28def54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83a8e7c2c40a4d41fc53c6b8d28def54">&#9670;&nbsp;</a></span>mpack_reader_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE void* mpack_reader_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the custom context for reader callbacks.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#ga0b209288e5aa980d3a2ed8aaf7fa72ce">mpack_reader_set_context</a> </dd>
<dd>
<a class="el" href="group__reader.html#gaf4eab68e9d1751ff9c6c853d563d9a0e">mpack_reader_set_fill</a> </dd>
<dd>
<a class="el" href="group__reader.html#gaa925114414e77ff809fcaaba399c8162">mpack_reader_set_skip</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l04622">4622</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gac04666405e21eea6e8819182571f0d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac04666405e21eea6e8819182571f0d20">&#9670;&nbsp;</a></span>mpack_reader_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> mpack_reader_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cleans up the MPack reader, ensuring that all compound elements have been completely read. Returns the final error state of the reader.</p>
<p>This will assert in tracking mode if the reader is not in an error state and has any incomplete reads. If you want to cancel reading in the middle of a document, you need to flag an error on the reader before destroying it (such as mpack_error_data).</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#ga70c00ecaf381e9711f6c1d0fa92f0c2f">mpack_read_tag()</a> </dd>
<dd>
<a class="el" href="group__reader.html#ga5c45c2e0592f16ae671cd509d8d8c512">mpack_reader_flag_error()</a> </dd>
<dd>
<a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ae53cbed8fcc42915d71ae37d121b22e8">mpack_error_data</a> </dd></dl>

</div>
</div>
<a id="ga8004b57cad188f6d315f5c4d36357272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8004b57cad188f6d315f5c4d36357272">&#9670;&nbsp;</a></span>mpack_reader_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> mpack_reader_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Queries the error state of the MPack reader.</p>
<p>If a reader is in an error state, you should discard all data since the last time the error flag was checked. The error flag cannot be cleared. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l04708">4708</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga5c45c2e0592f16ae671cd509d8d8c512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5c45c2e0592f16ae671cd509d8d8c512">&#9670;&nbsp;</a></span>mpack_reader_flag_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_flag_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Places the reader in the given error state, calling the error callback if one is set.</p>
<p>This allows you to externally flag errors, for example if you are validating data as you read it.</p>
<p>If the reader is already in an error state, this call is ignored and no error callback is called. </p>

</div>
</div>
<a id="ga15496dcbb58a2a66dfe97d8778d54274"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15496dcbb58a2a66dfe97d8778d54274">&#9670;&nbsp;</a></span>mpack_reader_flag_if_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> mpack_reader_flag_if_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Places the reader in the given error state if the given error is not mpack_ok, returning the resulting error state of the reader.</p>
<p>This allows you to externally flag errors, for example if you are validating data as you read it.</p>
<p>If the given error is mpack_ok or if the reader is already in an error state, this call is ignored and the actual error state of the reader is returned. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l04734">4734</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga1d79c00c6c013b879b164c26753b3e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d79c00c6c013b879b164c26753b3e83">&#9670;&nbsp;</a></span>mpack_reader_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an MPack reader with the given buffer. The reader does not assume ownership of the buffer, but the buffer must be writeable if a fill function will be used to refill it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer with which to read MessagePack data. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes already in the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga18f41d6786155f265769351ef550e331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18f41d6786155f265769351ef550e331">&#9670;&nbsp;</a></span>mpack_reader_init_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_init_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an MPack reader to parse a pre-loaded contiguous chunk of data. The reader does not assume ownership of the data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader. </td></tr>
    <tr><td class="paramname">data</td><td>The data to parse. </td></tr>
    <tr><td class="paramname">count</td><td>The number of bytes pointed to by data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga729bf4c0a79516e97a65d2e278f336e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga729bf4c0a79516e97a65d2e278f336e0">&#9670;&nbsp;</a></span>mpack_reader_init_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_init_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an MPack reader directly into an error state. Use this if you are writing a wrapper to <a class="el" href="group__reader.html#ga1d79c00c6c013b879b164c26753b3e83">mpack_reader_init()</a> which can fail its setup. </p>

</div>
</div>
<a id="ga58ae5ed702eec1edc717bb91912d0117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58ae5ed702eec1edc717bb91912d0117">&#9670;&nbsp;</a></span>mpack_reader_init_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE void mpack_reader_init_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deprecated.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000067">Deprecated:</a></b></dt><dd>Renamed to <a class="el" href="group__reader.html#gadf19892a6dd87d86bdd02646528964ff">mpack_reader_init_filename()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l04534">4534</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gadf19892a6dd87d86bdd02646528964ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadf19892a6dd87d86bdd02646528964ff">&#9670;&nbsp;</a></span>mpack_reader_init_filename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_init_filename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an MPack reader that reads from a file.</p>
<p>The file will be automatically opened and closed by the reader. </p>

</div>
</div>
<a id="ga97127332a566ac5fd7da541cad50bac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga97127332a566ac5fd7da541cad50bac4">&#9670;&nbsp;</a></span>mpack_reader_init_stdfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_init_stdfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stdfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>close_when_done</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an MPack reader that reads from a libc FILE. This can be used to read from stdin, or from a file opened separately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader. </td></tr>
    <tr><td class="paramname">stdfile</td><td>The FILE. </td></tr>
    <tr><td class="paramname">close_when_done</td><td>If true, fclose() will be called on the FILE when it is no longer needed. If false, the file will not be closed when reading is done.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The reader is buffered. It will read data in advance of parsing it, and it may read more data than it parsed. See <a class="el" href="group__reader.html#ga291a38358bde6992b16edda81f2fcf45">mpack_reader_remaining()</a> to access the extra data. </dd></dl>

</div>
</div>
<a id="ga291a38358bde6992b16edda81f2fcf45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga291a38358bde6992b16edda81f2fcf45">&#9670;&nbsp;</a></span>mpack_reader_remaining()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_reader_remaining </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns bytes left in the reader's buffer.</p>
<p>If you are done reading MessagePack data but there is other interesting data following it, the reader may have buffered too much data. The number of bytes remaining in the buffer and a pointer to the position of those bytes can be queried here.</p>
<p>If you know the length of the MPack chunk beforehand, it's better to instead have your fill function limit the data it reads so that the reader does not have extra data. In this case you can simply check that this returns zero.</p>
<p>Returns 0 if the reader is in an error state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader from which to query remaining data. </td></tr>
    <tr><td class="paramname">data</td><td>[out] A pointer to the remaining data, or NULL. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes remaining in the buffer. </dd></dl>

</div>
</div>
<a id="ga0b209288e5aa980d3a2ed8aaf7fa72ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0b209288e5aa980d3a2ed8aaf7fa72ce">&#9670;&nbsp;</a></span>mpack_reader_set_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE void mpack_reader_set_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the custom pointer to pass to the reader callbacks, such as fill or teardown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader. </td></tr>
    <tr><td class="paramname">context</td><td>User data to pass to the reader callbacks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#ga83a8e7c2c40a4d41fc53c6b8d28def54">mpack_reader_context()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l04611">4611</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gaa008b64c5a452b251f5b81717da3d404"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa008b64c5a452b251f5b81717da3d404">&#9670;&nbsp;</a></span>mpack_reader_set_error_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE void mpack_reader_set_error_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__reader.html#ga799a3f21adc8e229c6040ab42d90bef3">mpack_reader_error_t</a>&#160;</td>
          <td class="paramname"><em>error_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the error function to call when an error is flagged on the reader.</p>
<p>This should normally be used with <a class="el" href="group__reader.html#ga0b209288e5aa980d3a2ed8aaf7fa72ce">mpack_reader_set_context()</a> to register a custom pointer to pass to the error function.</p>
<p>See the definition of mpack_reader_error_t for more information about what you can do from an error callback.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#ga799a3f21adc8e229c6040ab42d90bef3">mpack_reader_error_t</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader. </td></tr>
    <tr><td class="paramname">error_fn</td><td>The function to call when an error is flagged on the reader. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l04676">4676</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gaf4eab68e9d1751ff9c6c853d563d9a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf4eab68e9d1751ff9c6c853d563d9a0e">&#9670;&nbsp;</a></span>mpack_reader_set_fill()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_set_fill </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__reader.html#ga97503ca06d41d58c60226b2732661eda">mpack_reader_fill_t</a>&#160;</td>
          <td class="paramname"><em>fill</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the fill function to refill the data buffer when it runs out of data.</p>
<p>If no fill function is used, truncated MessagePack data results in mpack_error_invalid (since the buffer is assumed to contain a complete MessagePack object.)</p>
<p>If a fill function is used, truncated MessagePack data usually results in mpack_error_io (since the fill function fails to get the missing data.)</p>
<p>This should normally be used with <a class="el" href="group__reader.html#ga0b209288e5aa980d3a2ed8aaf7fa72ce">mpack_reader_set_context()</a> to register a custom pointer to pass to the fill function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader. </td></tr>
    <tr><td class="paramname">fill</td><td>The function to fetch additional data into the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa925114414e77ff809fcaaba399c8162"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa925114414e77ff809fcaaba399c8162">&#9670;&nbsp;</a></span>mpack_reader_set_skip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_reader_set_skip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__reader.html#ga6a0b236c7befe9cb959dabce15acd23b">mpack_reader_skip_t</a>&#160;</td>
          <td class="paramname"><em>skip</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the skip function to discard bytes from the source stream.</p>
<p>It's not necessary to implement this function. If the stream is not seekable, don't set a skip callback. The reader will fall back to using the fill function instead.</p>
<p>This should normally be used with <a class="el" href="group__reader.html#ga0b209288e5aa980d3a2ed8aaf7fa72ce">mpack_reader_set_context()</a> to register a custom pointer to pass to the skip function.</p>
<p>The skip function is ignored in size-optimized builds to reduce code size. Data will be skipped with the fill function when necessary.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader. </td></tr>
    <tr><td class="paramname">skip</td><td>The function to discard bytes from the source stream. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaefab265bf5fb2867d69948f220570347"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaefab265bf5fb2867d69948f220570347">&#9670;&nbsp;</a></span>mpack_reader_set_teardown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE void mpack_reader_set_teardown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__reader.html#gadda6baaccdcf0ad9c5e212be9992cf5b">mpack_reader_teardown_t</a>&#160;</td>
          <td class="paramname"><em>teardown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the teardown function to call when the reader is destroyed.</p>
<p>This should normally be used with <a class="el" href="group__reader.html#ga0b209288e5aa980d3a2ed8aaf7fa72ce">mpack_reader_set_context()</a> to register a custom pointer to pass to the teardown function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The MPack reader. </td></tr>
    <tr><td class="paramname">teardown</td><td>The function to call when the reader is destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l04689">4689</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gac5cd4b489f3c5ffd3b5d114efb58a21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac5cd4b489f3c5ffd3b5d114efb58a21f">&#9670;&nbsp;</a></span>mpack_should_read_bytes_inplace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE bool mpack_should_read_bytes_inplace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if it's a good idea to read the given number of bytes in-place.</p>
<p>If the read will be larger than some small fraction of the buffer size, this will return false to avoid shuffling too much data back and forth in the buffer.</p>
<p>Use this if you're expecting arbitrary size data, and you want to read in-place for the best performance when possible but will fall back to a normal read if the data is too large.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572">mpack_read_bytes_inplace()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05025">5025</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga0c7e1dd2be56ce3d596326c4463e7229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0c7e1dd2be56ce3d596326c4463e7229">&#9670;&nbsp;</a></span>mpack_skip_bytes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_skip_bytes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Skips bytes from the underlying stream. This is used only to skip the contents of a string, binary blob or extension object. </p>

</div>
</div>
<a id="ga1cf5a2d9b687d94f637a36123ef7cec0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1cf5a2d9b687d94f637a36123ef7cec0">&#9670;&nbsp;</a></span>mpack_writer_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> mpack_writer_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cleans up the MPack writer, flushing and closing the underlying stream, if any. Returns the final error state of the writer.</p>
<p>No flushing is performed if the writer is in an error state. The attached teardown function is called whether or not the writer is in an error state.</p>
<p>This will assert in tracking mode if the writer is not in an error state and has any unclosed compound types. If you want to cancel writing in the middle of a document, you need to flag an error on the writer before destroying it (such as mpack_error_data).</p>
<p>Note that a writer may raise an error and call your error handler during the final flush. It is safe to longjmp or throw out of this error handler, but if you do, the writer will not be destroyed, and the teardown function will not be called. You can still get the writer's error state, and you must call <a class="el" href="group__reader.html#ga1cf5a2d9b687d94f637a36123ef7cec0">mpack_writer_destroy()</a> again. (The second call is guaranteed not to call your error handler again since the writer is already in an error state.)</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#gab7ebd9e04e546444625d8984a5fd42fc">mpack_writer_set_error_handler</a> </dd>
<dd>
<a class="el" href="group__writer.html#ga1337e25984152198814d94b8ddf2e1e1">mpack_writer_set_flush</a> </dd>
<dd>
<a class="el" href="group__writer.html#ga240c73ece1da9ee908be4fadfdd53777">mpack_writer_set_teardown</a> </dd>
<dd>
<a class="el" href="group__writer.html#gaf90e598304c7e8a423c534a5d554075e">mpack_writer_flag_error</a> </dd>
<dd>
<a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ae53cbed8fcc42915d71ae37d121b22e8">mpack_error_data</a> </dd></dl>

</div>
</div>
<a id="gabf46d5fd103d44d03c412cb7bb52e2d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf46d5fd103d44d03c412cb7bb52e2d0">&#9670;&nbsp;</a></span>mpack_writer_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_writer_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an MPack writer with the given buffer. The writer does not assume ownership of the buffer.</p>
<p>Trying to write past the end of the buffer will result in mpack_error_too_big unless a flush function is set with <a class="el" href="group__writer.html#ga1337e25984152198814d94b8ddf2e1e1">mpack_writer_set_flush()</a>. To use the data without flushing, call <a class="el" href="group__writer.html#gac5ea7ce1617bf85f2b2aac956ed40c22">mpack_writer_buffer_used()</a> to determine the number of bytes written.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writer</td><td>The MPack writer. </td></tr>
    <tr><td class="paramname">buffer</td><td>The buffer into which to write MessagePack data. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the buffer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab3c8d9ebe78513a17a38af28f387d169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3c8d9ebe78513a17a38af28f387d169">&#9670;&nbsp;</a></span>mpack_writer_init_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_writer_init_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an MPack writer directly into an error state. Use this if you are writing a wrapper to <a class="el" href="group__reader.html#gabf46d5fd103d44d03c412cb7bb52e2d0">mpack_writer_init()</a> which can fail its setup. </p>

</div>
</div>
<a id="ga15181d2c6766254010359db02f5b036a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga15181d2c6766254010359db02f5b036a">&#9670;&nbsp;</a></span>mpack_writer_init_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE void mpack_writer_init_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deprecated.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000066">Deprecated:</a></b></dt><dd>Renamed to <a class="el" href="group__reader.html#ga80c2f57160ec9e0efe02f2b3820a8661">mpack_writer_init_filename()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l03303">3303</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga80c2f57160ec9e0efe02f2b3820a8661"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80c2f57160ec9e0efe02f2b3820a8661">&#9670;&nbsp;</a></span>mpack_writer_init_filename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_writer_init_filename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an MPack writer that writes to a file.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_memory</td><td>if allocation fails </td></tr>
    <tr><td class="paramname">mpack_error_io</td><td>if the file cannot be opened </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0aa3b265fb5ece9c4cba0f2b1bfbdb53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0aa3b265fb5ece9c4cba0f2b1bfbdb53">&#9670;&nbsp;</a></span>mpack_writer_init_growable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_writer_init_growable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an MPack writer using a growable buffer.</p>
<p>The data is placed in the given data pointer if and when the writer is destroyed without error. The data pointer is NULL during writing, and will remain NULL if an error occurs.</p>
<p>The allocated data must be freed with <a class="el" href="group__config.html#ga298d7c2e4093bcfe361088df9e35956a">MPACK_FREE()</a> (or simply free() if MPack's allocator hasn't been customized.)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_memory</td><td>if the buffer fails to grow when flushing.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writer</td><td>The MPack writer. </td></tr>
    <tr><td class="paramname">data</td><td>Where to place the allocated data. </td></tr>
    <tr><td class="paramname">size</td><td>Where to write the size of the data. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gabe9a212641a4edd010ccdd9ecf888485"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabe9a212641a4edd010ccdd9ecf888485">&#9670;&nbsp;</a></span>mpack_writer_init_stdfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_writer_init_stdfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__writer.html#gabdb207d4ba6a6ae47efa5ede13436f31">mpack_writer_t</a> *&#160;</td>
          <td class="paramname"><em>writer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stdfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>close_when_done</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an MPack writer that writes to a libc FILE. This can be used to write to stdout or stderr, or to a file opened separately.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">writer</td><td>The MPack writer. </td></tr>
    <tr><td class="paramname">stdfile</td><td>The FILE. </td></tr>
    <tr><td class="paramname">close_when_done</td><td>If true, fclose() will be called on the FILE when it is no longer needed. If false, the file will not be flushed or closed when writing is done.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The writer is buffered. If you want to write other data to the FILE in between messages, you must flush it first.</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__writer.html#ga0e8649525969ae318bf0f125d8b55f50">mpack_writer_flush_message</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
