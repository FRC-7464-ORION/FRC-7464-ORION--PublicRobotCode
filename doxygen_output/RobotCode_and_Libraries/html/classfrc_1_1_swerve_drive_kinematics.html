<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RobotCode/WPILIBC(v2020.3.2): frc::SwerveDriveKinematics&lt; NumModules &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ORION.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">RobotCode/WPILIBC(v2020.3.2)
   &#160;<span id="projectnumber">v2020.1.0.03</span>
   </div>
   <div id="projectbrief">FRC 2020 Robot Code for Team #7464 - ORION</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classfrc_1_1_swerve_drive_kinematics.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classfrc_1_1_swerve_drive_kinematics-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">frc::SwerveDriveKinematics&lt; NumModules &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_swerve_drive_kinematics_8h_source.html">SwerveDriveKinematics.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab3e7aa018b138375414924e0493b73cd"><td class="memTemplParams" colspan="2">template&lt;typename... Wheels&gt; </td></tr>
<tr class="memitem:ab3e7aa018b138375414924e0493b73cd"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#ab3e7aa018b138375414924e0493b73cd">SwerveDriveKinematics</a> (<a class="el" href="classfrc_1_1_translation2d.html">Translation2d</a> wheel, Wheels &amp;&amp;... wheels)</td></tr>
<tr class="separator:ab3e7aa018b138375414924e0493b73cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16db9e36af1eb6ddf4c4dd2a49717fbd"><td class="memItemLeft" align="right" valign="top"><a id="a16db9e36af1eb6ddf4c4dd2a49717fbd"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>SwerveDriveKinematics</b> (const <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">SwerveDriveKinematics</a> &amp;)=default</td></tr>
<tr class="separator:a16db9e36af1eb6ddf4c4dd2a49717fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc73d1ccc4c3960e625beaca6bbbd6ff"><td class="memItemLeft" align="right" valign="top">std::array&lt; <a class="el" href="structfrc_1_1_swerve_module_state.html">SwerveModuleState</a>, NumModules &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#abc73d1ccc4c3960e625beaca6bbbd6ff">ToSwerveModuleStates</a> (const <a class="el" href="structfrc_1_1_chassis_speeds.html">ChassisSpeeds</a> &amp;chassisSpeeds, const <a class="el" href="classfrc_1_1_translation2d.html">Translation2d</a> &amp;centerOfRotation=<a class="el" href="classfrc_1_1_translation2d.html">Translation2d</a>())</td></tr>
<tr class="separator:abc73d1ccc4c3960e625beaca6bbbd6ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad238cbefaf224ce7e3f32407aee12150"><td class="memTemplParams" colspan="2">template&lt;typename... ModuleStates&gt; </td></tr>
<tr class="memitem:ad238cbefaf224ce7e3f32407aee12150"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structfrc_1_1_chassis_speeds.html">ChassisSpeeds</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#ad238cbefaf224ce7e3f32407aee12150">ToChassisSpeeds</a> (ModuleStates &amp;&amp;... wheelStates)</td></tr>
<tr class="separator:ad238cbefaf224ce7e3f32407aee12150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd3c51a4ede28efbc146bc8a891f7117"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structfrc_1_1_chassis_speeds.html">ChassisSpeeds</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#afd3c51a4ede28efbc146bc8a891f7117">ToChassisSpeeds</a> (std::array&lt; <a class="el" href="structfrc_1_1_swerve_module_state.html">SwerveModuleState</a>, NumModules &gt; moduleStates)</td></tr>
<tr class="separator:afd3c51a4ede28efbc146bc8a891f7117"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa5e408b1fb3f812de27d6abea9b72101"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html#aa5e408b1fb3f812de27d6abea9b72101">NormalizeWheelSpeeds</a> (std::array&lt; <a class="el" href="structfrc_1_1_swerve_module_state.html">SwerveModuleState</a>, NumModules &gt; *moduleStates, units::meters_per_second_t attainableMaxSpeed)</td></tr>
<tr class="separator:aa5e408b1fb3f812de27d6abea9b72101"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:ae30f3d5704701ab7f06c1517d71ce170"><td class="memItemLeft" align="right" valign="top"><a id="ae30f3d5704701ab7f06c1517d71ce170"></a>
Eigen::Matrix&lt; double, NumModules *2, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_inverseKinematics</b></td></tr>
<tr class="separator:ae30f3d5704701ab7f06c1517d71ce170"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fa7a8a3aba33a9556e5d3a6e1c2fbd"><td class="memItemLeft" align="right" valign="top"><a id="a44fa7a8a3aba33a9556e5d3a6e1c2fbd"></a>
Eigen::HouseholderQR&lt; Eigen::Matrix&lt; double, NumModules *2, 3 &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_forwardKinematics</b></td></tr>
<tr class="separator:a44fa7a8a3aba33a9556e5d3a6e1c2fbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7838512a92260c0492149079a099b26d"><td class="memItemLeft" align="right" valign="top"><a id="a7838512a92260c0492149079a099b26d"></a>
std::array&lt; <a class="el" href="classfrc_1_1_translation2d.html">Translation2d</a>, NumModules &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>m_modules</b></td></tr>
<tr class="separator:a7838512a92260c0492149079a099b26d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a178babb693e734823531aba827264001"><td class="memItemLeft" align="right" valign="top"><a id="a178babb693e734823531aba827264001"></a>
<a class="el" href="classfrc_1_1_translation2d.html">Translation2d</a>&#160;</td><td class="memItemRight" valign="bottom"><b>m_previousCoR</b></td></tr>
<tr class="separator:a178babb693e734823531aba827264001"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;size_t NumModules&gt;<br />
class frc::SwerveDriveKinematics&lt; NumModules &gt;</h3>

<p>Helper class that converts a chassis velocity (dx, dy, and dtheta components) into individual module states (speed and angle).</p>
<p>The inverse kinematics (converting from a desired chassis velocity to individual module states) uses the relative locations of the modules with respect to the center of rotation. The center of rotation for inverse kinematics is also variable. This means that you can set your set your center of rotation in a corner of the robot to perform special evasion manuevers.</p>
<p>Forward kinematics (converting an array of module states into the overall chassis motion) is performs the exact opposite of what inverse kinematics does. Since this is an overdetermined system (more equations than variables), we use a least-squares approximation.</p>
<p>The inverse kinematics: [moduleStates] = [moduleLocations] * [chassisSpeeds] We take the Moore-Penrose pseudoinverse of [moduleLocations] and then multiply by [moduleStates] to get our chassis speeds.</p>
<p>Forward kinematics is also used for odometry &ndash; determining the position of the robot on the field using encoders and a gyro. </p>

<p class="definition">Definition at line <a class="el" href="_swerve_drive_kinematics_8h_source.html#l00047">47</a> of file <a class="el" href="_swerve_drive_kinematics_8h_source.html">SwerveDriveKinematics.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab3e7aa018b138375414924e0493b73cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3e7aa018b138375414924e0493b73cd">&#9670;&nbsp;</a></span>SwerveDriveKinematics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
<div class="memtemplate">
template&lt;typename... Wheels&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::<a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">SwerveDriveKinematics</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classfrc_1_1_translation2d.html">Translation2d</a>&#160;</td>
          <td class="paramname"><em>wheel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Wheels &amp;&amp;...&#160;</td>
          <td class="paramname"><em>wheels</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">explicit</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Constructs a swerve drive kinematics object. This takes in a variable number of wheel locations as Translation2ds. The order in which you pass in the wheel locations is the same order that you will recieve the module states when performing inverse kinematics. It is also expected that you pass in the module states in the same order when calling the forward kinematics methods.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wheels</td><td>The locations of the wheels relative to the physical center of the robot. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="_swerve_drive_kinematics_8h_source.html#l00061">61</a> of file <a class="el" href="_swerve_drive_kinematics_8h_source.html">SwerveDriveKinematics.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa5e408b1fb3f812de27d6abea9b72101"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e408b1fb3f812de27d6abea9b72101">&#9670;&nbsp;</a></span>NormalizeWheelSpeeds()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::NormalizeWheelSpeeds </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; <a class="el" href="structfrc_1_1_swerve_module_state.html">SwerveModuleState</a>, NumModules &gt; *&#160;</td>
          <td class="paramname"><em>moduleStates</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">units::meters_per_second_t&#160;</td>
          <td class="paramname"><em>attainableMaxSpeed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Normalizes the wheel speeds using some max attainable speed. Sometimes, after inverse kinematics, the requested speed from a/several modules may be above the max attainable speed for the driving motor on that module. To fix this issue, one can "normalize" all the wheel speeds to make sure that all requested module speeds are below the absolute threshold, while maintaining the ratio of speeds between modules.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleStates</td><td>Reference to array of module states. The array will be mutated with the normalized speeds! </td></tr>
    <tr><td class="paramname">attainableMaxSpeed</td><td>The absolute max speed that a module can reach. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad238cbefaf224ce7e3f32407aee12150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad238cbefaf224ce7e3f32407aee12150">&#9670;&nbsp;</a></span>ToChassisSpeeds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
<div class="memtemplate">
template&lt;typename... ModuleStates&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfrc_1_1_chassis_speeds.html">ChassisSpeeds</a> <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::ToChassisSpeeds </td>
          <td>(</td>
          <td class="paramtype">ModuleStates &amp;&amp;...&#160;</td>
          <td class="paramname"><em>wheelStates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs forward kinematics to return the resulting chassis state from the given module states. This method is often used for odometry &ndash; determining the robot's position on the field using data from the real-world speed and angle of each module on the robot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">wheelStates</td><td>The state of the modules (as a <a class="el" href="structfrc_1_1_swerve_module_state.html">SwerveModuleState</a> type) as measured from respective encoders and gyros. The order of the swerve module states should be same as passed into the constructor of this class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting chassis speed. </dd></dl>

</div>
</div>
<a id="afd3c51a4ede28efbc146bc8a891f7117"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd3c51a4ede28efbc146bc8a891f7117">&#9670;&nbsp;</a></span>ToChassisSpeeds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structfrc_1_1_chassis_speeds.html">ChassisSpeeds</a> <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::ToChassisSpeeds </td>
          <td>(</td>
          <td class="paramtype">std::array&lt; <a class="el" href="structfrc_1_1_swerve_module_state.html">SwerveModuleState</a>, NumModules &gt;&#160;</td>
          <td class="paramname"><em>moduleStates</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs forward kinematics to return the resulting chassis state from the given module states. This method is often used for odometry &ndash; determining the robot's position on the field using data from the real-world speed and angle of each module on the robot.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">moduleStates</td><td>The state of the modules as an std::array of type <a class="el" href="structfrc_1_1_swerve_module_state.html">SwerveModuleState</a>, NumModules long as measured from respective encoders and gyros. The order of the swerve module states should be same as passed into the constructor of this class.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting chassis speed. </dd></dl>

</div>
</div>
<a id="abc73d1ccc4c3960e625beaca6bbbd6ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc73d1ccc4c3960e625beaca6bbbd6ff">&#9670;&nbsp;</a></span>ToSwerveModuleStates()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t NumModules&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::array&lt;<a class="el" href="structfrc_1_1_swerve_module_state.html">SwerveModuleState</a>, NumModules&gt; <a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">frc::SwerveDriveKinematics</a>&lt; NumModules &gt;::ToSwerveModuleStates </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structfrc_1_1_chassis_speeds.html">ChassisSpeeds</a> &amp;&#160;</td>
          <td class="paramname"><em>chassisSpeeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classfrc_1_1_translation2d.html">Translation2d</a> &amp;&#160;</td>
          <td class="paramname"><em>centerOfRotation</em> = <code><a class="el" href="classfrc_1_1_translation2d.html">Translation2d</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs inverse kinematics to return the module states from a desired chassis velocity. This method is often used to convert joystick values into module speeds and angles.</p>
<p>This function also supports variable centers of rotation. During normal operations, the center of rotation is usually the same as the physical center of the robot; therefore, the argument is defaulted to that use case. However, if you wish to change the center of rotation for evasive manuevers, vision alignment, or for any other use case, you can do so.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">chassisSpeeds</td><td>The desired chassis speed. </td></tr>
    <tr><td class="paramname">centerOfRotation</td><td>The center of rotation. For example, if you set the center of rotation at one corner of the robot and provide a chassis speed that only has a dtheta component, the robot will rotate around that corner.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An array containing the module states. Use caution because these module states are not normalized. Sometimes, a user input may cause one of the module speeds to go above the attainable max velocity. Use the &lt;NormalizeWheelSpeeds&gt; function to rectify this issue. In addition, you can leverage the power of C++17 to directly assign the module states to variables:</dd></dl>
<div class="fragment"><div class="line"><span class="keyword">auto</span> [fl, fr, bl, br] = kinematics.ToSwerveModuleStates(chassisSpeeds);</div></div><!-- fragment --> 
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>C:/ORION22/allwpilib/wpilibc/src/main/native/include/frc/kinematics/<a class="el" href="_swerve_drive_kinematics_8h_source.html">SwerveDriveKinematics.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespacefrc.html">frc</a></li><li class="navelem"><a class="el" href="classfrc_1_1_swerve_drive_kinematics.html">SwerveDriveKinematics</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
