<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NewRobotCode/WPILIBC(v2022.3.1): Expect API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ORION.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NewRobotCode/WPILIBC(v2022.3.1)
   &#160;<span id="projectnumber">v2022.0.0.28</span>
   </div>
   <div id="projectbrief">FRC 2022 Robot Code for Team #7464 - ORION</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__expect.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Expect API</div>  </div>
</div><!--header-->
<div class="contents">

<p>The MPack Expect API allows you to easily read MessagePack data when you expect it to follow a predefined schema.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Other Basic Types</h2></td></tr>
<tr class="memitem:gada69acbd6803f79cab7573ae9ebc37bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gada69acbd6803f79cab7573ae9ebc37bd">mpack_expect_nil</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gada69acbd6803f79cab7573ae9ebc37bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaeafa42ca3ae974494f127eb4b56ed8ae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gaeafa42ca3ae974494f127eb4b56ed8ae">mpack_expect_bool</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gaeafa42ca3ae974494f127eb4b56ed8ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaadfca446696881a598cc4f90892ded88"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gaadfca446696881a598cc4f90892ded88">mpack_expect_true</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gaadfca446696881a598cc4f90892ded88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa29ab364a7ae092e93a20b1a24744c0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__writer.html#gaa29ab364a7ae092e93a20b1a24744c0e">mpack_expect_false</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gaa29ab364a7ae092e93a20b1a24744c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Basic Number Functions</h2></td></tr>
<tr class="memitem:gab1310dc54c39ac7754ee62d635a82976"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab1310dc54c39ac7754ee62d635a82976">mpack_expect_u8</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gab1310dc54c39ac7754ee62d635a82976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad267aebef43d94bc7891939d1fc2d51a"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad267aebef43d94bc7891939d1fc2d51a">mpack_expect_u16</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gad267aebef43d94bc7891939d1fc2d51a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccb728859e5944214324a23979fe0aa2"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaccb728859e5944214324a23979fe0aa2">mpack_expect_u32</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gaccb728859e5944214324a23979fe0aa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab2dbbc0830bc08f2e7ce851782ec06e5"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab2dbbc0830bc08f2e7ce851782ec06e5">mpack_expect_u64</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gab2dbbc0830bc08f2e7ce851782ec06e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga728dc9cb317871bbf3360361a713d471"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga728dc9cb317871bbf3360361a713d471">mpack_expect_i8</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:ga728dc9cb317871bbf3360361a713d471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8ef3886fd34471e00136a672b6cfbfa"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad8ef3886fd34471e00136a672b6cfbfa">mpack_expect_i16</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gad8ef3886fd34471e00136a672b6cfbfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddca7f73951f581f0ddf03f6755322cf"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaddca7f73951f581f0ddf03f6755322cf">mpack_expect_i32</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gaddca7f73951f581f0ddf03f6755322cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad93d24fe9e68a1dd94054b70095ebcfb"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad93d24fe9e68a1dd94054b70095ebcfb">mpack_expect_i64</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gad93d24fe9e68a1dd94054b70095ebcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49c6bea0c4d7e14a636d703ffe304264"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga49c6bea0c4d7e14a636d703ffe304264">mpack_expect_float</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:ga49c6bea0c4d7e14a636d703ffe304264"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga51a47ece249cd4d6d795bf3211fde745"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga51a47ece249cd4d6d795bf3211fde745">mpack_expect_double</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:ga51a47ece249cd4d6d795bf3211fde745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4d56f4be6f5376ebfa6fcd0ebac6cce1"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga4d56f4be6f5376ebfa6fcd0ebac6cce1">mpack_expect_float_strict</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:ga4d56f4be6f5376ebfa6fcd0ebac6cce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad676ff64ce7933cade0c85da8a83799f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad676ff64ce7933cade0c85da8a83799f">mpack_expect_double_strict</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gad676ff64ce7933cade0c85da8a83799f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab8647f981912fce1e6e2488e9363203f"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab8647f981912fce1e6e2488e9363203f">mpack_expect_uint</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gab8647f981912fce1e6e2488e9363203f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafa6a72180c961479aee2b3548b0709c"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaafa6a72180c961479aee2b3548b0709c">mpack_expect_int</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gaafa6a72180c961479aee2b3548b0709c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Ranged Number Functions</h2></td></tr>
<tr class="memitem:gab3922088844e8cb301a6c2a5c5750d4f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab3922088844e8cb301a6c2a5c5750d4f">mpack_expect_u8_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint8_t min_value, uint8_t max_value)</td></tr>
<tr class="separator:gab3922088844e8cb301a6c2a5c5750d4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6f984713bc3b24b044a99cd6f4e58b7"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gad6f984713bc3b24b044a99cd6f4e58b7">mpack_expect_u16_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint16_t min_value, uint16_t max_value)</td></tr>
<tr class="separator:gad6f984713bc3b24b044a99cd6f4e58b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1e3a8ce7d88676ed38f7d4aaf22d0d9c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga1e3a8ce7d88676ed38f7d4aaf22d0d9c">mpack_expect_u32_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t min_value, uint32_t max_value)</td></tr>
<tr class="separator:ga1e3a8ce7d88676ed38f7d4aaf22d0d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7110dc658b713b292e9cafee3ccb7424"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga7110dc658b713b292e9cafee3ccb7424">mpack_expect_u64_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint64_t min_value, uint64_t max_value)</td></tr>
<tr class="separator:ga7110dc658b713b292e9cafee3ccb7424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga087d6400f93017449ccea63814bde166"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga087d6400f93017449ccea63814bde166">mpack_expect_uint_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, unsigned int min_value, unsigned int max_value)</td></tr>
<tr class="separator:ga087d6400f93017449ccea63814bde166"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1f51bfc36369d947ff83feabd0b384f8"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga1f51bfc36369d947ff83feabd0b384f8">mpack_expect_u8_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint8_t max_value)</td></tr>
<tr class="separator:ga1f51bfc36369d947ff83feabd0b384f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadedb20d43880fe4b7f8b361148911d3e"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gadedb20d43880fe4b7f8b361148911d3e">mpack_expect_u16_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint16_t max_value)</td></tr>
<tr class="separator:gadedb20d43880fe4b7f8b361148911d3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabd9aedcd4ab5b1989d158ebdf213375b"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gabd9aedcd4ab5b1989d158ebdf213375b">mpack_expect_u32_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t max_value)</td></tr>
<tr class="separator:gabd9aedcd4ab5b1989d158ebdf213375b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaddd2baa03c1d7455447b6229a1085229"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaddd2baa03c1d7455447b6229a1085229">mpack_expect_u64_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint64_t max_value)</td></tr>
<tr class="separator:gaddd2baa03c1d7455447b6229a1085229"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadc752e276eae8fa4e984c37f435af06a"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gadc752e276eae8fa4e984c37f435af06a">mpack_expect_uint_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, unsigned int max_value)</td></tr>
<tr class="separator:gadc752e276eae8fa4e984c37f435af06a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa553c386f7ad6d05423835d31a439461"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaa553c386f7ad6d05423835d31a439461">mpack_expect_i8_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int8_t min_value, int8_t max_value)</td></tr>
<tr class="separator:gaa553c386f7ad6d05423835d31a439461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c4464418c0444854b3ab39785491a4b"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga6c4464418c0444854b3ab39785491a4b">mpack_expect_i16_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int16_t min_value, int16_t max_value)</td></tr>
<tr class="separator:ga6c4464418c0444854b3ab39785491a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga217f2065c5f039209f93cddbdbf01bee"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga217f2065c5f039209f93cddbdbf01bee">mpack_expect_i32_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int32_t min_value, int32_t max_value)</td></tr>
<tr class="separator:ga217f2065c5f039209f93cddbdbf01bee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7f7356f1e0638a076fac1a8db87f4f53"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga7f7356f1e0638a076fac1a8db87f4f53">mpack_expect_i64_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int64_t min_value, int64_t max_value)</td></tr>
<tr class="separator:ga7f7356f1e0638a076fac1a8db87f4f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6c0d3d6062a4707532424a830eb891a7"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga6c0d3d6062a4707532424a830eb891a7">mpack_expect_int_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int min_value, int max_value)</td></tr>
<tr class="separator:ga6c0d3d6062a4707532424a830eb891a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga252256033247679b1388394b15bd4150"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga252256033247679b1388394b15bd4150">mpack_expect_i8_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int8_t max_value)</td></tr>
<tr class="separator:ga252256033247679b1388394b15bd4150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6af562a659ba195b47b6148a1aba71fb"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga6af562a659ba195b47b6148a1aba71fb">mpack_expect_i16_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int16_t max_value)</td></tr>
<tr class="separator:ga6af562a659ba195b47b6148a1aba71fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga723c0e8e586c3421e975295f6821f9c0"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga723c0e8e586c3421e975295f6821f9c0">mpack_expect_i32_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int32_t max_value)</td></tr>
<tr class="separator:ga723c0e8e586c3421e975295f6821f9c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaffb9b2f8b1bd762fa9c56e025fa7be52"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaffb9b2f8b1bd762fa9c56e025fa7be52">mpack_expect_i64_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int64_t max_value)</td></tr>
<tr class="separator:gaffb9b2f8b1bd762fa9c56e025fa7be52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5b8d83bdb9957037ff2fb6d18e12b45b"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga5b8d83bdb9957037ff2fb6d18e12b45b">mpack_expect_int_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int max_value)</td></tr>
<tr class="separator:ga5b8d83bdb9957037ff2fb6d18e12b45b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fffadf5032a669d582025f5131b53e2"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga0fffadf5032a669d582025f5131b53e2">mpack_expect_float_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, float min_value, float max_value)</td></tr>
<tr class="separator:ga0fffadf5032a669d582025f5131b53e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga63f44e3d23db5e24d86b0b714f9ff95b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga63f44e3d23db5e24d86b0b714f9ff95b">mpack_expect_double_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, double min_value, double max_value)</td></tr>
<tr class="separator:ga63f44e3d23db5e24d86b0b714f9ff95b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Matching Number Functions</h2></td></tr>
<tr class="memitem:ga005303e0b2c39809fcd5172228fae282"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga005303e0b2c39809fcd5172228fae282">mpack_expect_uint_match</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint64_t <a class="el" href="classvalue.html">value</a>)</td></tr>
<tr class="separator:ga005303e0b2c39809fcd5172228fae282"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8992b669afbaffee6ac8f336022611aa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga8992b669afbaffee6ac8f336022611aa">mpack_expect_int_match</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, int64_t <a class="el" href="classvalue.html">value</a>)</td></tr>
<tr class="separator:ga8992b669afbaffee6ac8f336022611aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Compound Types</h2></td></tr>
<tr class="memitem:ga44a2941b8e8ec379748c238fab52bda1"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga44a2941b8e8ec379748c238fab52bda1">mpack_expect_map</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:ga44a2941b8e8ec379748c238fab52bda1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa2d131161862c386e9f048ad93fb3d45"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaa2d131161862c386e9f048ad93fb3d45">mpack_expect_map_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t min_count, uint32_t max_count)</td></tr>
<tr class="separator:gaa2d131161862c386e9f048ad93fb3d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga34f13989e9ef81f9ce84b6ab20490b44"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga34f13989e9ef81f9ce84b6ab20490b44">mpack_expect_map_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t max_count)</td></tr>
<tr class="separator:ga34f13989e9ef81f9ce84b6ab20490b44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab66c8c170be1b394b397ccc041d6c133"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab66c8c170be1b394b397ccc041d6c133">mpack_expect_map_match</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t count)</td></tr>
<tr class="separator:gab66c8c170be1b394b397ccc041d6c133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee3ac5d2ea0dc864b5898673a67c69ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaee3ac5d2ea0dc864b5898673a67c69ee">mpack_expect_map_or_nil</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t *count)</td></tr>
<tr class="separator:gaee3ac5d2ea0dc864b5898673a67c69ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2aae8867b092afd5a2350d4701687b35"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga2aae8867b092afd5a2350d4701687b35">mpack_expect_map_max_or_nil</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t max_count, uint32_t *count)</td></tr>
<tr class="separator:ga2aae8867b092afd5a2350d4701687b35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga18285492fd04458fb7ab0d151bea0402"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga18285492fd04458fb7ab0d151bea0402">mpack_expect_array</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:ga18285492fd04458fb7ab0d151bea0402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c0b7dd785576183e5444691c7d32b90"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga4c0b7dd785576183e5444691c7d32b90">mpack_expect_array_range</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t min_count, uint32_t max_count)</td></tr>
<tr class="separator:ga4c0b7dd785576183e5444691c7d32b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga79e4e85c0a8de69b5efa51d46469927b"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga79e4e85c0a8de69b5efa51d46469927b">mpack_expect_array_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t max_count)</td></tr>
<tr class="separator:ga79e4e85c0a8de69b5efa51d46469927b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga799bb820a49f5a8a70e604466f8ab9b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga799bb820a49f5a8a70e604466f8ab9b5">mpack_expect_array_match</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t count)</td></tr>
<tr class="separator:ga799bb820a49f5a8a70e604466f8ab9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f3202b0ed8916b311e2c225172afdb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga2f3202b0ed8916b311e2c225172afdb3">mpack_expect_array_or_nil</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t *count)</td></tr>
<tr class="separator:ga2f3202b0ed8916b311e2c225172afdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad5153a6d29bebf8251ba5beb1aaef3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga0ad5153a6d29bebf8251ba5beb1aaef3">mpack_expect_array_max_or_nil</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t max_count, uint32_t *count)</td></tr>
<tr class="separator:ga0ad5153a6d29bebf8251ba5beb1aaef3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7e69ee365f459dec5cdc3c797c7d0642"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga7e69ee365f459dec5cdc3c797c7d0642">mpack_expect_array_alloc</a>(reader,  Type,  max_count,  out_count)</td></tr>
<tr class="separator:ga7e69ee365f459dec5cdc3c797c7d0642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaccad78065b48e2fd3c15c32e91927a75"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gaccad78065b48e2fd3c15c32e91927a75">mpack_expect_array_or_nil_alloc</a>(reader,  Type,  max_count,  out_count)</td></tr>
<tr class="separator:gaccad78065b48e2fd3c15c32e91927a75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
String Functions</h2></td></tr>
<tr class="memitem:ga6baba88194988c9f423630052d59f7fd"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga6baba88194988c9f423630052d59f7fd">mpack_expect_str</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:ga6baba88194988c9f423630052d59f7fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga658205c994cf8fce528f4c8a3a957a14"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga658205c994cf8fce528f4c8a3a957a14">mpack_expect_str_buf</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *buf, size_t bufsize)</td></tr>
<tr class="separator:ga658205c994cf8fce528f4c8a3a957a14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c44c450649514ee1a31e567d39f0bf0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga8c44c450649514ee1a31e567d39f0bf0">mpack_expect_utf8</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *buf, size_t bufsize)</td></tr>
<tr class="separator:ga8c44c450649514ee1a31e567d39f0bf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7aaa9082437438819a369cb2dd37e219"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga7aaa9082437438819a369cb2dd37e219">mpack_expect_str_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t maxsize)</td></tr>
<tr class="separator:ga7aaa9082437438819a369cb2dd37e219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b385c622f60ecf96d03699beeb7d110"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga6b385c622f60ecf96d03699beeb7d110">mpack_expect_str_length</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t count)</td></tr>
<tr class="separator:ga6b385c622f60ecf96d03699beeb7d110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3ceade6375ab699c1ef05ef9f5c2ff90"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga3ceade6375ab699c1ef05ef9f5c2ff90">mpack_expect_str_match</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, const char *str, size_t length)</td></tr>
<tr class="separator:ga3ceade6375ab699c1ef05ef9f5c2ff90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga94489d03628c1fb1a3d0ac6971600fe8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga94489d03628c1fb1a3d0ac6971600fe8">mpack_expect_cstr</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *buf, size_t size)</td></tr>
<tr class="separator:ga94489d03628c1fb1a3d0ac6971600fe8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga62be63032f3c84181eeed4609f0dddb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga62be63032f3c84181eeed4609f0dddb4">mpack_expect_utf8_cstr</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *buf, size_t size)</td></tr>
<tr class="separator:ga62be63032f3c84181eeed4609f0dddb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6d2d920a0ed7d39e251ac8d6f077998"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gab6d2d920a0ed7d39e251ac8d6f077998">mpack_expect_cstr_alloc</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t maxsize)</td></tr>
<tr class="separator:gab6d2d920a0ed7d39e251ac8d6f077998"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5acb7f64d13ce1a09670377cbbbf68c7"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga5acb7f64d13ce1a09670377cbbbf68c7">mpack_expect_utf8_cstr_alloc</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t maxsize)</td></tr>
<tr class="separator:ga5acb7f64d13ce1a09670377cbbbf68c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae7b860394f1a0b34df0e46a134ca7550"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gae7b860394f1a0b34df0e46a134ca7550">mpack_expect_cstr_match</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, const char *cstr)</td></tr>
<tr class="separator:gae7b860394f1a0b34df0e46a134ca7550"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Binary Data</h2></td></tr>
<tr class="memitem:gadcf7fc94ae30ed5c3752291a0efd43c5"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gadcf7fc94ae30ed5c3752291a0efd43c5">mpack_expect_bin</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader)</td></tr>
<tr class="separator:gadcf7fc94ae30ed5c3752291a0efd43c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga83aad117d06b01c181d0c684664041e3"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga83aad117d06b01c181d0c684664041e3">mpack_expect_bin_max</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t maxsize)</td></tr>
<tr class="separator:ga83aad117d06b01c181d0c684664041e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbba5fca75b8eba015ccd7c12debd6a4"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gadbba5fca75b8eba015ccd7c12debd6a4">mpack_expect_bin_size</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, uint32_t count)</td></tr>
<tr class="separator:gadbba5fca75b8eba015ccd7c12debd6a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98004c26b9ebc1b80b4bdec5a1d4b093"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga98004c26b9ebc1b80b4bdec5a1d4b093">mpack_expect_bin_buf</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *buf, size_t size)</td></tr>
<tr class="separator:ga98004c26b9ebc1b80b4bdec5a1d4b093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac420e7fbce284cf4ec7d4467171a1b8b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gac420e7fbce284cf4ec7d4467171a1b8b">mpack_expect_bin_size_buf</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, char *buf, uint32_t size)</td></tr>
<tr class="separator:gac420e7fbce284cf4ec7d4467171a1b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga513a9ce0e5bf78128d2d174bf1434538"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga513a9ce0e5bf78128d2d174bf1434538">mpack_expect_bin_alloc</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, size_t maxsize, size_t *size)</td></tr>
<tr class="separator:ga513a9ce0e5bf78128d2d174bf1434538"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Special Functions</h2></td></tr>
<tr class="memitem:ga6e9c48430fa233615ec9b5439f9ed451"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga6e9c48430fa233615ec9b5439f9ed451">mpack_expect_tag</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, <a class="el" href="group__common.html#ga008da69ac6b5582a893f2d2ffd37f4ac">mpack_tag_t</a> tag)</td></tr>
<tr class="separator:ga6e9c48430fa233615ec9b5439f9ed451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga65a2a909774f3205887ae446ea4089f0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga65a2a909774f3205887ae446ea4089f0">mpack_expect_enum</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, const char *strings[], size_t count)</td></tr>
<tr class="separator:ga65a2a909774f3205887ae446ea4089f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5763a0063111ffdfe8f193fb42e7fea4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga5763a0063111ffdfe8f193fb42e7fea4">mpack_expect_enum_optional</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, const char *strings[], size_t count)</td></tr>
<tr class="separator:ga5763a0063111ffdfe8f193fb42e7fea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga78f80d9fabe961d661eabe95732c2d59"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#ga78f80d9fabe961d661eabe95732c2d59">mpack_expect_key_uint</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, bool found[], size_t count)</td></tr>
<tr class="separator:ga78f80d9fabe961d661eabe95732c2d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada27a479e6ad56faaa14528d1a3dfb26"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__expect.html#gada27a479e6ad56faaa14528d1a3dfb26">mpack_expect_key_cstr</a> (<a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *reader, const char *keys[], bool found[], size_t count)</td></tr>
<tr class="separator:gada27a479e6ad56faaa14528d1a3dfb26"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The MPack Expect API allows you to easily read MessagePack data when you expect it to follow a predefined schema. </p>
<dl class="section note"><dt>Note</dt><dd>If you are not writing code for an embedded device (or otherwise do not need maximum performance with minimal memory usage), you should not use this. You probably want to use the <a class="el" href="group__node.html">Node API</a> instead.</dd></dl>
<p>See docs/expect.md for examples.</p>
<p>The main purpose of the Expect API is convenience, so the API is lax. It automatically converts between similar types where there is no loss of precision.</p>
<p>When using any of the expect functions, if the type or value of what was read does not match what is expected, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised. </p>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a id="ga7e69ee365f459dec5cdc3c797c7d0642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7e69ee365f459dec5cdc3c797c7d0642">&#9670;&nbsp;</a></span>mpack_expect_array_alloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mpack_expect_array_alloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reader, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">max_count, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">out_count&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the start of an array and allocates storage for it, placing its size in out_count. A number of objects follow equal to the element count of the array. You must call <a class="el" href="group__reader.html#ga2b5b8fd101d63c96b6b89e675c981b78">mpack_done_array()</a> when done (even if the element count is zero.)</p>
<p>If an error occurs, NULL is returned and the reader is placed in an error state.</p>
<p>If the count is zero, NULL is returned. This does not indicate error. You should not check the return value for NULL to check for errors; only check the reader's error state.</p>
<p>The allocated array must be freed with <a class="el" href="group__config.html#ga298d7c2e4093bcfe361088df9e35956a">MPACK_FREE()</a> (or simply free() if MPack's allocator hasn't been customized.)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not an array or if its size is greater than max_count. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l06139">6139</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gaccad78065b48e2fd3c15c32e91927a75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccad78065b48e2fd3c15c32e91927a75">&#9670;&nbsp;</a></span>mpack_expect_array_or_nil_alloc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define mpack_expect_array_or_nil_alloc</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">reader, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">Type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">max_count, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">out_count&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a nil node or the start of an array and allocates storage for it, placing its size in out_count. A number of objects follow equal to the element count of the array if a non-empty array was read.</p>
<p>If an error occurs, NULL is returned and the reader is placed in an error state.</p>
<p>If a nil node was read, NULL is returned. If an empty array was read, <a class="el" href="group__reader.html#ga2b5b8fd101d63c96b6b89e675c981b78">mpack_done_array()</a> is called automatically and NULL is returned. These do not indicate error. You should not check the return value for NULL to check for errors; only check the reader's error state.</p>
<p>The allocated array must be freed with <a class="el" href="group__config.html#ga298d7c2e4093bcfe361088df9e35956a">MPACK_FREE()</a> (or simply free() if MPack's allocator hasn't been customized.)</p>
<dl class="section warning"><dt>Warning</dt><dd>You must call <a class="el" href="group__reader.html#ga2b5b8fd101d63c96b6b89e675c981b78">mpack_done_array()</a> if and only if a non-zero element count is read. This function does not differentiate between nil and an empty array.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not an array or if its size is greater than max_count. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l06167">6167</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga18285492fd04458fb7ab0d151bea0402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga18285492fd04458fb7ab0d151bea0402">&#9670;&nbsp;</a></span>mpack_expect_array()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_array </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the start of an array, returning its element count.</p>
<p>A number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#ga2b5b8fd101d63c96b6b89e675c981b78">mpack_done_array()</a> must be called once all elements have been read.</p>
<dl class="section warning"><dt>Warning</dt><dd>This call is dangerous! It does not have a size limit, and it does not have any way of checking whether there is enough data in the message (since the data could be coming from a stream.) When looping through the array's contents, you must check for errors on each iteration of the loop. Otherwise an attacker could craft a message declaring an array of a billion elements which would throw your parsing code into an infinite loop! You should strongly consider using <a class="el" href="group__expect.html#ga79e4e85c0a8de69b5efa51d46469927b">mpack_expect_array_max()</a> with a safe maximum size instead. </dd></dl>

</div>
</div>
<a id="ga799bb820a49f5a8a70e604466f8ab9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga799bb820a49f5a8a70e604466f8ab9b5">&#9670;&nbsp;</a></span>mpack_expect_array_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_array_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the start of an array of the exact size given.</p>
<p>A number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#ga2b5b8fd101d63c96b6b89e675c981b78">mpack_done_array()</a> must be called once all elements have been read.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not an array or if its size does not match the given count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga79e4e85c0a8de69b5efa51d46469927b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga79e4e85c0a8de69b5efa51d46469927b">&#9670;&nbsp;</a></span>mpack_expect_array_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE uint32_t mpack_expect_array_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the start of an array with a number of elements at most <em>max_count</em>, returning its element count.</p>
<p>A number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#ga2b5b8fd101d63c96b6b89e675c981b78">mpack_done_array()</a> must be called once all elements have been read.</p>
<p>Zero is returned if an error occurs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not an array or if its size is greater than max_count. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l06064">6064</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga0ad5153a6d29bebf8251ba5beb1aaef3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ad5153a6d29bebf8251ba5beb1aaef3">&#9670;&nbsp;</a></span>mpack_expect_array_max_or_nil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_expect_array_max_or_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a nil node or the start of an array with a number of elements at most max_count, returning whether an array was read and placing its number of key/value pairs in count.</p>
<p>If an array was read, a number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#ga2b5b8fd101d63c96b6b89e675c981b78">mpack_done_array()</a> should also be called once all elements have been read (only if an array was read.)</p>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an array was read successfully; <code>false</code> if nil was read or an error occurred. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a nil or array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2f3202b0ed8916b311e2c225172afdb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2f3202b0ed8916b311e2c225172afdb3">&#9670;&nbsp;</a></span>mpack_expect_array_or_nil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_expect_array_or_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a nil node or the start of an array, returning whether an array was read and placing its number of elements in count.</p>
<p>If an array was read, a number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#ga2b5b8fd101d63c96b6b89e675c981b78">mpack_done_array()</a> should also be called once all elements have been read (only if an array was read.)</p>
<dl class="section warning"><dt>Warning</dt><dd>This call is dangerous! It does not have a size limit, and it does not have any way of checking whether there is enough data in the message (since the data could be coming from a stream.) When looping through the array's contents, you must check for errors on each iteration of the loop. Otherwise an attacker could craft a message declaring an array of a billion elements which would throw your parsing code into an infinite loop! You should strongly consider using <a class="el" href="group__expect.html#ga0ad5153a6d29bebf8251ba5beb1aaef3">mpack_expect_array_max_or_nil()</a> with a safe maximum size instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if an array was read successfully; <code>false</code> if nil was read or an error occurred. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a nil or array. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4c0b7dd785576183e5444691c7d32b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4c0b7dd785576183e5444691c7d32b90">&#9670;&nbsp;</a></span>mpack_expect_array_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_array_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>min_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the start of an array with a number of elements in the given range, returning its element count.</p>
<p>A number of values follow equal to the element count of the array. <a class="el" href="group__reader.html#ga2b5b8fd101d63c96b6b89e675c981b78">mpack_done_array()</a> must be called once all elements have been read.</p>
<p>min_count is returned if an error occurs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not an array or if its size does not fall within the given range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gadcf7fc94ae30ed5c3752291a0efd43c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcf7fc94ae30ed5c3752291a0efd43c5">&#9670;&nbsp;</a></span>mpack_expect_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_bin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the start of a binary blob, returning its size in bytes.</p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0">mpack_done_bin()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a binary blob. </p>

</div>
</div>
<a id="ga513a9ce0e5bf78128d2d174bf1434538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga513a9ce0e5bf78128d2d174bf1434538">&#9670;&nbsp;</a></span>mpack_expect_bin_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_expect_bin_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a binary blob with the given total maximum size, allocating storage for it. </p>

</div>
</div>
<a id="ga98004c26b9ebc1b80b4bdec5a1d4b093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga98004c26b9ebc1b80b4bdec5a1d4b093">&#9670;&nbsp;</a></span>mpack_expect_bin_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_bin_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a binary blob into the given buffer, returning its size in bytes.</p>
<p>For compatibility, this will accept if the underlying type is string or binary (since in MessagePack 1.0, strings and binary data were combined under the "raw" type which became string in 1.1.) </p>

</div>
</div>
<a id="ga83aad117d06b01c181d0c684664041e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga83aad117d06b01c181d0c684664041e3">&#9670;&nbsp;</a></span>mpack_expect_bin_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE uint32_t mpack_expect_bin_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the start of a binary blob, raising an error if its length is not at most the given number of bytes.</p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0">mpack_done_bin()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a binary blob or if its length does not match. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l06378">6378</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gadbba5fca75b8eba015ccd7c12debd6a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbba5fca75b8eba015ccd7c12debd6a4">&#9670;&nbsp;</a></span>mpack_expect_bin_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE void mpack_expect_bin_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the start of a binary blob, raising an error if its length is not exactly the given number of bytes.</p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0">mpack_done_bin()</a> must be called once all bytes have been read.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a binary blob or if its size does not match. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l06398">6398</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gac420e7fbce284cf4ec7d4467171a1b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac420e7fbce284cf4ec7d4467171a1b8b">&#9670;&nbsp;</a></span>mpack_expect_bin_size_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_bin_size_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a binary blob with the exact given size into the given buffer.</p>
<p>For compatibility, this will accept if the underlying type is string or binary (since in MessagePack 1.0, strings and binary data were combined under the "raw" type which became string in 1.1.)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a binary blob or if its size does not match. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaeafa42ca3ae974494f127eb4b56ed8ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaeafa42ca3ae974494f127eb4b56ed8ae">&#9670;&nbsp;</a></span>mpack_expect_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_expect_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a boolean.</p>
<dl class="section note"><dt>Note</dt><dd>Integers will raise mpack_error_type; the value must be strictly a boolean. </dd></dl>

</div>
</div>
<a id="ga94489d03628c1fb1a3d0ac6971600fe8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga94489d03628c1fb1a3d0ac6971600fe8">&#9670;&nbsp;</a></span>mpack_expect_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a string into the given buffer, ensures it has no null bytes, and adds a null-terminator at the end.</p>
<p>Raises mpack_error_too_big if there is not enough room for the string and null-terminator. Raises mpack_error_type if the value is not a string or contains a null byte. </p>

</div>
</div>
<a id="gab6d2d920a0ed7d39e251ac8d6f077998"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab6d2d920a0ed7d39e251ac8d6f077998">&#9670;&nbsp;</a></span>mpack_expect_cstr_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_expect_cstr_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a string with the given total maximum size (including space for a null-terminator), allocates storage for it, ensures it has no null-bytes, and adds a null-terminator at the end. You assume ownership of the returned pointer if reading succeeds.</p>
<p>The allocated string must be freed with <a class="el" href="group__config.html#ga298d7c2e4093bcfe361088df9e35956a">MPACK_FREE()</a> (or simply free() if MPack's allocator hasn't been customized.)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_too_big</td><td>If the string plus null-terminator is larger than the given maxsize. </td></tr>
    <tr><td class="paramname">mpack_error_type</td><td>If the value is not a string or contains a null byte. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae7b860394f1a0b34df0e46a134ca7550"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae7b860394f1a0b34df0e46a134ca7550">&#9670;&nbsp;</a></span>mpack_expect_cstr_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE void mpack_expect_cstr_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a string, ensuring it exactly matches the given null-terminated string.</p>
<p>Remember that maps are unordered in JSON. Don't use this for map keys unless the map has only a single key! </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l06342">6342</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga51a47ece249cd4d6d795bf3211fde745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga51a47ece249cd4d6d795bf3211fde745">&#9670;&nbsp;</a></span>mpack_expect_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mpack_expect_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a number, returning the value as a double. The underlying value can be an integer, float or double; the value is converted to a double.</p>
<dl class="section note"><dt>Note</dt><dd>Reading a very large integer with this function can incur a loss of precision.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga63f44e3d23db5e24d86b0b714f9ff95b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga63f44e3d23db5e24d86b0b714f9ff95b">&#9670;&nbsp;</a></span>mpack_expect_double_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mpack_expect_double_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a number, ensuring that it falls within the given range and returning the value as a double. The underlying value can be an integer, float or double; the value is converted to a double.</p>
<dl class="section note"><dt>Note</dt><dd>Reading a very large integer with this function can incur a loss of precision.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad676ff64ce7933cade0c85da8a83799f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad676ff64ce7933cade0c85da8a83799f">&#9670;&nbsp;</a></span>mpack_expect_double_strict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mpack_expect_double_strict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a double. The underlying value must be a float or double, not an integer. This ensures no loss of precision can occur.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float or double. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga65a2a909774f3205887ae446ea4089f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga65a2a909774f3205887ae446ea4089f0">&#9670;&nbsp;</a></span>mpack_expect_enum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_enum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>strings</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expects a string matching one of the strings in the given array, returning its array index.</p>
<p>If the value does not match any of the given strings, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is flagged. Use <a class="el" href="group__expect.html#ga5763a0063111ffdfe8f193fb42e7fea4">mpack_expect_enum_optional()</a> if you want to allow other values than the given strings.</p>
<p>If any error occurs or the reader is in an error state, <em>count</em> is returned.</p>
<p>This can be used to quickly parse a string into an enum when the enum values range from 0 to <em>count-1</em>. If the last value in the enum is a special "count" value, it can be passed as the count, and the return value can be cast directly to the enum type.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>           { APPLE ,  BANANA ,  ORANGE , COUNT} fruit_t;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* fruits[] = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>};</div>
<div class="line"> </div>
<div class="line">fruit_t fruit = (fruit_t)<a class="code" href="group__expect.html#ga65a2a909774f3205887ae446ea4089f0">mpack_expect_enum</a>(reader, fruits, COUNT);</div>
</div><!-- fragment --><p>See docs/expect.md for more examples.</p>
<p>The maximum string length is the size of the buffer (strings are read in-place.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The reader </td></tr>
    <tr><td class="paramname">strings</td><td>An array of expected strings of length count </td></tr>
    <tr><td class="paramname">count</td><td>The number of strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the matched string, or <em>count</em> in case of error </dd></dl>

</div>
</div>
<a id="ga5763a0063111ffdfe8f193fb42e7fea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5763a0063111ffdfe8f193fb42e7fea4">&#9670;&nbsp;</a></span>mpack_expect_enum_optional()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_enum_optional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>strings</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expects a string matching one of the strings in the given array returning its array index, or <em>count</em> if no strings match.</p>
<p>If the value is not a string, or it does not match any of the given strings, <em>count</em> is returned and no error is flagged.</p>
<p>If any error occurs or the reader is in an error state, <em>count</em> is returned.</p>
<p>This can be used to quickly parse a string into an enum when the enum values range from 0 to <em>count-1</em>. If the last value in the enum is a special "count" value, it can be passed as the count, and the return value can be cast directly to the enum type.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>           { APPLE ,  BANANA ,  ORANGE , COUNT} fruit_t;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* fruits[] = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>};</div>
<div class="line"> </div>
<div class="line">fruit_t fruit = (fruit_t)<a class="code" href="group__expect.html#ga5763a0063111ffdfe8f193fb42e7fea4">mpack_expect_enum_optional</a>(reader, fruits, COUNT);</div>
</div><!-- fragment --><p>See docs/expect.md for more examples.</p>
<p>The maximum string length is the size of the buffer (strings are read in-place.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The reader </td></tr>
    <tr><td class="paramname">strings</td><td>An array of expected strings of length count </td></tr>
    <tr><td class="paramname">count</td><td>The number of strings</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the matched string, or <em>count</em> if it does not match or an error occurs </dd></dl>

</div>
</div>
<a id="gaa29ab364a7ae092e93a20b1a24744c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa29ab364a7ae092e93a20b1a24744c0e">&#9670;&nbsp;</a></span>mpack_expect_false()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_false </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a boolean, raising <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> if its value is not <code>false</code>. </p>

</div>
</div>
<a id="ga49c6bea0c4d7e14a636d703ffe304264"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga49c6bea0c4d7e14a636d703ffe304264">&#9670;&nbsp;</a></span>mpack_expect_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mpack_expect_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a number, returning the value as a float. The underlying value can be an integer, float or double; the value is converted to a float.</p>
<dl class="section note"><dt>Note</dt><dd>Reading a double or a large integer with this function can incur a loss of precision.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga0fffadf5032a669d582025f5131b53e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0fffadf5032a669d582025f5131b53e2">&#9670;&nbsp;</a></span>mpack_expect_float_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mpack_expect_float_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a number, ensuring that it falls within the given range and returning the value as a float. The underlying value can be an integer, float or double; the value is converted to a float.</p>
<dl class="section note"><dt>Note</dt><dd>Reading a double or a large integer with this function can incur a loss of precision.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga4d56f4be6f5376ebfa6fcd0ebac6cce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga4d56f4be6f5376ebfa6fcd0ebac6cce1">&#9670;&nbsp;</a></span>mpack_expect_float_strict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mpack_expect_float_strict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a float. The underlying value must be a float, not a double or an integer. This ensures no loss of precision can occur.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gad8ef3886fd34471e00136a672b6cfbfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8ef3886fd34471e00136a672b6cfbfa">&#9670;&nbsp;</a></span>mpack_expect_i16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t mpack_expect_i16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 16-bit signed integer.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit signed int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a id="ga6af562a659ba195b47b6148a1aba71fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6af562a659ba195b47b6148a1aba71fb">&#9670;&nbsp;</a></span>mpack_expect_i16_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE int16_t mpack_expect_i16_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 16-bit signed integer, ensuring that it is at least zero and at most <em>max_value</em>.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit signed int.</p>
<p>Returns 0 if an error occurs. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05681">5681</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga6c4464418c0444854b3ab39785491a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c4464418c0444854b3ab39785491a4b">&#9670;&nbsp;</a></span>mpack_expect_i16_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t mpack_expect_i16_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int16_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 16-bit signed integer, ensuring that it falls within the given range.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit signed int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a id="gaddca7f73951f581f0ddf03f6755322cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddca7f73951f581f0ddf03f6755322cf">&#9670;&nbsp;</a></span>mpack_expect_i32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mpack_expect_i32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 32-bit signed integer.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit signed int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a id="ga723c0e8e586c3421e975295f6821f9c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga723c0e8e586c3421e975295f6821f9c0">&#9670;&nbsp;</a></span>mpack_expect_i32_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE int32_t mpack_expect_i32_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 32-bit signed integer, ensuring that it is at least zero and at most <em>max_value</em>.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit signed int.</p>
<p>Returns 0 if an error occurs. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05694">5694</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga217f2065c5f039209f93cddbdbf01bee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga217f2065c5f039209f93cddbdbf01bee">&#9670;&nbsp;</a></span>mpack_expect_i32_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mpack_expect_i32_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 32-bit signed integer, ensuring that it falls within the given range.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit signed int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a id="gad93d24fe9e68a1dd94054b70095ebcfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad93d24fe9e68a1dd94054b70095ebcfb">&#9670;&nbsp;</a></span>mpack_expect_i64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpack_expect_i64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 64-bit signed integer.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit signed int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a id="gaffb9b2f8b1bd762fa9c56e025fa7be52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaffb9b2f8b1bd762fa9c56e025fa7be52">&#9670;&nbsp;</a></span>mpack_expect_i64_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE int64_t mpack_expect_i64_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 64-bit signed integer, ensuring that it is at least zero and at most <em>max_value</em>.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit signed int.</p>
<p>Returns 0 if an error occurs. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05707">5707</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga7f7356f1e0638a076fac1a8db87f4f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7f7356f1e0638a076fac1a8db87f4f53">&#9670;&nbsp;</a></span>mpack_expect_i64_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpack_expect_i64_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 64-bit signed integer, ensuring that it falls within the given range.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit signed int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a id="ga728dc9cb317871bbf3360361a713d471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga728dc9cb317871bbf3360361a713d471">&#9670;&nbsp;</a></span>mpack_expect_i8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t mpack_expect_i8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an 8-bit signed integer.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit signed int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a id="ga252256033247679b1388394b15bd4150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga252256033247679b1388394b15bd4150">&#9670;&nbsp;</a></span>mpack_expect_i8_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE int8_t mpack_expect_i8_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an 8-bit signed integer, ensuring that it is at least zero and at most <em>max_value</em>.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit signed int.</p>
<p>Returns 0 if an error occurs. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05668">5668</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gaa553c386f7ad6d05423835d31a439461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa553c386f7ad6d05423835d31a439461">&#9670;&nbsp;</a></span>mpack_expect_i8_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t mpack_expect_i8_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an 8-bit signed integer, ensuring that it falls within the given range.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit signed int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a id="gaafa6a72180c961479aee2b3548b0709c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaafa6a72180c961479aee2b3548b0709c">&#9670;&nbsp;</a></span>mpack_expect_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE int mpack_expect_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a signed int.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a signed int.</p>
<p>Returns zero if an error occurs. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05791">5791</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga8992b669afbaffee6ac8f336022611aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8992b669afbaffee6ac8f336022611aa">&#9670;&nbsp;</a></span>mpack_expect_int_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_int_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a signed integer, ensuring that it exactly matches the given value.</p>
<p>mpack_error_type is raised if the value is not representable as a signed integer or if it does not exactly match the given value. </p>

</div>
</div>
<a id="ga5b8d83bdb9957037ff2fb6d18e12b45b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5b8d83bdb9957037ff2fb6d18e12b45b">&#9670;&nbsp;</a></span>mpack_expect_int_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE int mpack_expect_int_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an int, ensuring that it is at least zero and at most <em>max_value</em>.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a signed int.</p>
<p>Returns 0 if an error occurs. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05719">5719</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga6c0d3d6062a4707532424a830eb891a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6c0d3d6062a4707532424a830eb891a7">&#9670;&nbsp;</a></span>mpack_expect_int_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE int mpack_expect_int_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a signed integer, ensuring that it falls within the given range.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a signed int.</p>
<p>Returns min_value if an error occurs. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05651">5651</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gada27a479e6ad56faaa14528d1a3dfb26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada27a479e6ad56faaa14528d1a3dfb26">&#9670;&nbsp;</a></span>mpack_expect_key_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_key_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>keys</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>found</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expects a string map key matching one of the strings in the given key list, marking it as found in the given bool array and returning its index.</p>
<p>This is a helper for switching among string keys in a map. It is typically used with an enum with names matching the strings in the array to define the key indices. It should be called in the expression of a switch() statement. See docs/expect.md for an example.</p>
<p>The found array must be cleared before expecting the first key. If the flag for a given key is already set when found (i.e. the map contains a duplicate key), mpack_error_invalid is flagged.</p>
<p>If the key is unrecognized, count is returned and no error is flagged. If you want an error on unrecognized keys, flag an error in the default case in your switch; otherwise you must call <a class="el" href="group__reader.html#ga438bb2b85fbbd06cd8f10d5c8079427e">mpack_discard()</a> to discard its content.</p>
<p>The maximum key length is the size of the buffer (keys are read in-place.)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The reader </td></tr>
    <tr><td class="paramname">keys</td><td>An array of expected string keys of length count </td></tr>
    <tr><td class="paramname">found</td><td>An array of bool flags of length count </td></tr>
    <tr><td class="paramname">count</td><td>The number of values in the keys and found arrays</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>docs/expect.md </dd></dl>

</div>
</div>
<a id="ga78f80d9fabe961d661eabe95732c2d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga78f80d9fabe961d661eabe95732c2d59">&#9670;&nbsp;</a></span>mpack_expect_key_uint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_key_uint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>found</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expects an unsigned integer map key between 0 and count-1, marking it as found in the given bool array and returning it.</p>
<p>This is a helper for switching among int keys in a map. It is typically used with an enum to define the key values. It should be called in the expression of a switch() statement. See docs/expect.md for an example.</p>
<p>The found array must be cleared before expecting the first key. If the flag for a given key is already set when found (i.e. the map contains a duplicate key), mpack_error_invalid is flagged.</p>
<p>If the key is not a non-negative integer, or if the key is <em>count</em> or larger, <em>count</em> is returned and no error is flagged. If you want an error on unrecognized keys, flag an error in the default case in your switch; otherwise you must call <a class="el" href="group__reader.html#ga438bb2b85fbbd06cd8f10d5c8079427e">mpack_discard()</a> to discard its content.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reader</td><td>The reader </td></tr>
    <tr><td class="paramname">found</td><td>An array of bool flags of length count </td></tr>
    <tr><td class="paramname">count</td><td>The number of values in the found array, and one more than the maximum allowed key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>docs/expect.md </dd></dl>

</div>
</div>
<a id="ga44a2941b8e8ec379748c238fab52bda1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga44a2941b8e8ec379748c238fab52bda1">&#9670;&nbsp;</a></span>mpack_expect_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the start of a map, returning its element count.</p>
<p>A number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> must be called once all elements have been read.</p>
<dl class="section note"><dt>Note</dt><dd>Maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This call is dangerous! It does not have a size limit, and it does not have any way of checking whether there is enough data in the message (since the data could be coming from a stream.) When looping through the map's contents, you must check for errors on each iteration of the loop. Otherwise an attacker could craft a message declaring a map of a billion elements which would throw your parsing code into an infinite loop! You should strongly consider using <a class="el" href="group__expect.html#ga34f13989e9ef81f9ce84b6ab20490b44">mpack_expect_map_max()</a> with a safe maximum size instead.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gab66c8c170be1b394b397ccc041d6c133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab66c8c170be1b394b397ccc041d6c133">&#9670;&nbsp;</a></span>mpack_expect_map_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_map_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the start of a map of the exact size given.</p>
<p>A number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> must be called once all elements have been read.</p>
<dl class="section note"><dt>Note</dt><dd>Maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a map or if its size does not match the given count. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga34f13989e9ef81f9ce84b6ab20490b44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga34f13989e9ef81f9ce84b6ab20490b44">&#9670;&nbsp;</a></span>mpack_expect_map_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE uint32_t mpack_expect_map_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the start of a map with a number of elements at most <em>max_count</em>, returning its element count.</p>
<p>A number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> must be called once all elements have been read.</p>
<dl class="section note"><dt>Note</dt><dd>Maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</dd></dl>
<p>Zero is returned if an error occurs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a map or if its size is greater than max_count. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05954">5954</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga2aae8867b092afd5a2350d4701687b35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2aae8867b092afd5a2350d4701687b35">&#9670;&nbsp;</a></span>mpack_expect_map_max_or_nil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_expect_map_max_or_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a nil node or the start of a map with a number of elements at most max_count, returning whether a map was read and placing its number of key/value pairs in count.</p>
<p>If a map was read, a number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> should anlso be called once all elements have been read (only if a map was read.)</p>
<dl class="section note"><dt>Note</dt><dd>Maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON. Consider using <a class="el" href="group__expect.html#gada27a479e6ad56faaa14528d1a3dfb26">mpack_expect_key_cstr()</a> or <a class="el" href="group__expect.html#ga78f80d9fabe961d661eabe95732c2d59">mpack_expect_key_uint()</a> to switch on the key; see docs/expect.md for examples.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a map was read successfully; <code>false</code> if nil was read or an error occurred. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a nil or map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaee3ac5d2ea0dc864b5898673a67c69ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaee3ac5d2ea0dc864b5898673a67c69ee">&#9670;&nbsp;</a></span>mpack_expect_map_or_nil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_expect_map_or_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a nil node or the start of a map, returning whether a map was read and placing its number of key/value pairs in count.</p>
<p>If a map was read, a number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> should also be called once all elements have been read (only if a map was read.)</p>
<dl class="section note"><dt>Note</dt><dd>Maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</dd></dl>
<dl class="section warning"><dt>Warning</dt><dd>This call is dangerous! It does not have a size limit, and it does not have any way of checking whether there is enough data in the message (since the data could be coming from a stream.) When looping through the map's contents, you must check for errors on each iteration of the loop. Otherwise an attacker could craft a message declaring a map of a billion elements which would throw your parsing code into an infinite loop! You should strongly consider using <a class="el" href="group__expect.html#ga2aae8867b092afd5a2350d4701687b35">mpack_expect_map_max_or_nil()</a> with a safe maximum size instead.</dd></dl>
<dl class="section return"><dt>Returns</dt><dd><code>true</code> if a map was read successfully; <code>false</code> if nil was read or an error occurred. </dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a nil or map. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa2d131161862c386e9f048ad93fb3d45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa2d131161862c386e9f048ad93fb3d45">&#9670;&nbsp;</a></span>mpack_expect_map_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_map_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>min_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the start of a map with a number of elements in the given range, returning its element count.</p>
<p>A number of values follow equal to twice the element count of the map, alternating between keys and values. <a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> must be called once all elements have been read.</p>
<dl class="section note"><dt>Note</dt><dd>Maps in JSON are unordered, so it is recommended not to expect a specific ordering for your map values in case your data is converted to/from JSON.</dd></dl>
<p>min_count is returned if an error occurs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the value is not a map or if its size does not fall within the given range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gada69acbd6803f79cab7573ae9ebc37bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada69acbd6803f79cab7573ae9ebc37bd">&#9670;&nbsp;</a></span>mpack_expect_nil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a nil, raising <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> if the value is not nil. </p>

</div>
</div>
<a id="ga6baba88194988c9f423630052d59f7fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6baba88194988c9f423630052d59f7fd">&#9670;&nbsp;</a></span>mpack_expect_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the start of a string, returning its size in bytes.</p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6">mpack_done_str()</a> must be called once all bytes have been read.</p>
<p>NUL bytes are allowed in the string, and no encoding checks are done.</p>
<p>mpack_error_type is raised if the value is not a string. </p>

</div>
</div>
<a id="ga658205c994cf8fce528f4c8a3a957a14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga658205c994cf8fce528f4c8a3a957a14">&#9670;&nbsp;</a></span>mpack_expect_str_buf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_str_buf </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a string of at most the given size, writing it into the given buffer and returning its size in bytes.</p>
<p>This does not add a null-terminator! Use <a class="el" href="group__expect.html#ga94489d03628c1fb1a3d0ac6971600fe8">mpack_expect_cstr()</a> to add a null-terminator.</p>
<p>NUL bytes are allowed in the string, and no encoding checks are done. </p>

</div>
</div>
<a id="ga6b385c622f60ecf96d03699beeb7d110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6b385c622f60ecf96d03699beeb7d110">&#9670;&nbsp;</a></span>mpack_expect_str_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE void mpack_expect_str_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the start of a string, raising an error if its length is not exactly the given number of bytes (not including any null-terminator.)</p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6">mpack_done_str()</a> must be called once all bytes have been read.</p>
<p>mpack_error_type is raised if the value is not a string or if its length does not match. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l06260">6260</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga3ceade6375ab699c1ef05ef9f5c2ff90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3ceade6375ab699c1ef05ef9f5c2ff90">&#9670;&nbsp;</a></span>mpack_expect_str_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_str_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a string, ensuring it exactly matches the given string.</p>
<p>Remember that maps are unordered in JSON. Don't use this for map keys unless the map has only a single key! </p>

</div>
</div>
<a id="ga7aaa9082437438819a369cb2dd37e219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7aaa9082437438819a369cb2dd37e219">&#9670;&nbsp;</a></span>mpack_expect_str_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE uint32_t mpack_expect_str_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the start of a string, raising an error if its length is not at most the given number of bytes (not including any null-terminator.)</p>
<p>The bytes follow and must be read separately with <a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c">mpack_read_bytes()</a> or <a class="el" href="group__reader.html#ga654d697da6a0eaf25246adf3ed343572">mpack_read_bytes_inplace()</a>. <a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6">mpack_done_str()</a> must be called once all bytes have been read.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the value is not a string. </td></tr>
    <tr><td class="paramname">mpack_error_too_big</td><td>If the string's length in bytes is larger than the given maximum size. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l06240">6240</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga6e9c48430fa233615ec9b5439f9ed451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6e9c48430fa233615ec9b5439f9ed451">&#9670;&nbsp;</a></span>mpack_expect_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga008da69ac6b5582a893f2d2ffd37f4ac">mpack_tag_t</a>&#160;</td>
          <td class="paramname"><em>tag</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a MessagePack object header (an MPack tag), expecting it to exactly match the given tag.</p>
<p>If the type is compound (i.e. is a map, array, string, binary or extension type), additional reads are required to get the contained data, and the corresponding done function must be called when done.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the tag does not match</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#gaeb91e8d4e2a7b7f6562d8bbb7400275c">mpack_read_bytes()</a> </dd>
<dd>
<a class="el" href="group__reader.html#ga2b5b8fd101d63c96b6b89e675c981b78">mpack_done_array()</a> </dd>
<dd>
<a class="el" href="group__reader.html#ga86165fc780e7adef09f4b45aee54842a">mpack_done_map()</a> </dd>
<dd>
<a class="el" href="group__reader.html#gaaad37015e0c53704d9356de06b493de6">mpack_done_str()</a> </dd>
<dd>
<a class="el" href="group__reader.html#gaa4676c4b0761de4f864fd81c347a15a0">mpack_done_bin()</a> </dd>
<dd>
mpack_done_ext() </dd></dl>

</div>
</div>
<a id="gaadfca446696881a598cc4f90892ded88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaadfca446696881a598cc4f90892ded88">&#9670;&nbsp;</a></span>mpack_expect_true()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_true </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a boolean, raising <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> if its value is not <code>true</code>. </p>

</div>
</div>
<a id="gad267aebef43d94bc7891939d1fc2d51a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad267aebef43d94bc7891939d1fc2d51a">&#9670;&nbsp;</a></span>mpack_expect_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t mpack_expect_u16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 16-bit unsigned integer.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit unsigned int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a id="gadedb20d43880fe4b7f8b361148911d3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadedb20d43880fe4b7f8b361148911d3e">&#9670;&nbsp;</a></span>mpack_expect_u16_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE uint16_t mpack_expect_u16_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 16-bit unsigned integer, ensuring that it is at most <em>max_value</em>.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit unsigned int.</p>
<p>Returns 0 if an error occurs. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05563">5563</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gad6f984713bc3b24b044a99cd6f4e58b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad6f984713bc3b24b044a99cd6f4e58b7">&#9670;&nbsp;</a></span>mpack_expect_u16_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t mpack_expect_u16_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 16-bit unsigned integer, ensuring that it falls within the given range.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 16-bit unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a id="gaccb728859e5944214324a23979fe0aa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaccb728859e5944214324a23979fe0aa2">&#9670;&nbsp;</a></span>mpack_expect_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_u32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 32-bit unsigned integer.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit unsigned int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a id="gabd9aedcd4ab5b1989d158ebdf213375b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabd9aedcd4ab5b1989d158ebdf213375b">&#9670;&nbsp;</a></span>mpack_expect_u32_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE uint32_t mpack_expect_u32_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 32-bit unsigned integer, ensuring that it is at most <em>max_value</em>.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit unsigned int.</p>
<p>Returns 0 if an error occurs. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05575">5575</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga1e3a8ce7d88676ed38f7d4aaf22d0d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1e3a8ce7d88676ed38f7d4aaf22d0d9c">&#9670;&nbsp;</a></span>mpack_expect_u32_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_expect_u32_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 32-bit unsigned integer, ensuring that it falls within the given range.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 32-bit unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a id="gab2dbbc0830bc08f2e7ce851782ec06e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab2dbbc0830bc08f2e7ce851782ec06e5">&#9670;&nbsp;</a></span>mpack_expect_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mpack_expect_u64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 64-bit unsigned integer.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit unsigned int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a id="gaddd2baa03c1d7455447b6229a1085229"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaddd2baa03c1d7455447b6229a1085229">&#9670;&nbsp;</a></span>mpack_expect_u64_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE uint64_t mpack_expect_u64_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 64-bit unsigned integer, ensuring that it is at most <em>max_value</em>.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit unsigned int.</p>
<p>Returns 0 if an error occurs. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05587">5587</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga7110dc658b713b292e9cafee3ccb7424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7110dc658b713b292e9cafee3ccb7424">&#9670;&nbsp;</a></span>mpack_expect_u64_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mpack_expect_u64_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a 64-bit unsigned integer, ensuring that it falls within the given range.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in a 64-bit unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a id="gab1310dc54c39ac7754ee62d635a82976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1310dc54c39ac7754ee62d635a82976">&#9670;&nbsp;</a></span>mpack_expect_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mpack_expect_u8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an 8-bit unsigned integer.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit unsigned int.</p>
<p>Returns zero if an error occurs. </p>

</div>
</div>
<a id="ga1f51bfc36369d947ff83feabd0b384f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1f51bfc36369d947ff83feabd0b384f8">&#9670;&nbsp;</a></span>mpack_expect_u8_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE uint8_t mpack_expect_u8_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an 8-bit unsigned integer, ensuring that it is at most <em>max_value</em>.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit unsigned int.</p>
<p>Returns 0 if an error occurs. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05551">5551</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gab3922088844e8cb301a6c2a5c5750d4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab3922088844e8cb301a6c2a5c5750d4f">&#9670;&nbsp;</a></span>mpack_expect_u8_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mpack_expect_u8_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an 8-bit unsigned integer, ensuring that it falls within the given range.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an 8-bit unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

</div>
</div>
<a id="gab8647f981912fce1e6e2488e9363203f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab8647f981912fce1e6e2488e9363203f">&#9670;&nbsp;</a></span>mpack_expect_uint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE unsigned int mpack_expect_uint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned int.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an unsigned int.</p>
<p>Returns zero if an error occurs. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05772">5772</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga005303e0b2c39809fcd5172228fae282"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga005303e0b2c39809fcd5172228fae282">&#9670;&nbsp;</a></span>mpack_expect_uint_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_uint_match </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned integer, ensuring that it exactly matches the given value.</p>
<p>mpack_error_type is raised if the value is not representable as an unsigned integer or if it does not exactly match the given value. </p>

</div>
</div>
<a id="gadc752e276eae8fa4e984c37f435af06a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadc752e276eae8fa4e984c37f435af06a">&#9670;&nbsp;</a></span>mpack_expect_uint_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE unsigned int mpack_expect_uint_max </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned integer, ensuring that it is at most <em>max_value</em>.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an unsigned int.</p>
<p>Returns 0 if an error occurs. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05599">5599</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga087d6400f93017449ccea63814bde166"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga087d6400f93017449ccea63814bde166">&#9670;&nbsp;</a></span>mpack_expect_uint_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE unsigned int mpack_expect_uint_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>max_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads an unsigned integer, ensuring that it falls within the given range.</p>
<p>The underlying type may be an integer type of any size and signedness, as long as the value can be represented in an unsigned int.</p>
<p>Returns min_value if an error occurs. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l05535">5535</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga8c44c450649514ee1a31e567d39f0bf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c44c450649514ee1a31e567d39f0bf0">&#9670;&nbsp;</a></span>mpack_expect_utf8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_expect_utf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a string into the given buffer, ensuring it is a valid UTF-8 string and returning its size in bytes.</p>
<p>This does not add a null-terminator! Use <a class="el" href="group__expect.html#ga62be63032f3c84181eeed4609f0dddb4">mpack_expect_utf8_cstr()</a> to add a null-terminator.</p>
<p>This does not accept any UTF-8 variant such as Modified UTF-8, CESU-8 or WTF-8. Only pure UTF-8 is allowed.</p>
<p>NUL bytes are allowed in the string (as they are in UTF-8.)</p>
<p>Raises mpack_error_too_big if there is not enough room for the string. Raises mpack_error_type if the value is not a string or is not a valid UTF-8 string. </p>

</div>
</div>
<a id="ga62be63032f3c84181eeed4609f0dddb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga62be63032f3c84181eeed4609f0dddb4">&#9670;&nbsp;</a></span>mpack_expect_utf8_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_expect_utf8_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a string into the given buffer, ensures it is a valid UTF-8 string without NUL characters, and adds a null-terminator at the end.</p>
<p>This does not accept any UTF-8 variant such as Modified UTF-8, CESU-8 or WTF-8. Only pure UTF-8 is allowed, but without the NUL character, since it cannot be represented in a null-terminated string.</p>
<p>Raises mpack_error_too_big if there is not enough room for the string and null-terminator. Raises mpack_error_type if the value is not a string or is not a valid UTF-8 string. </p>

</div>
</div>
<a id="ga5acb7f64d13ce1a09670377cbbbf68c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5acb7f64d13ce1a09670377cbbbf68c7">&#9670;&nbsp;</a></span>mpack_expect_utf8_cstr_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_expect_utf8_cstr_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__reader.html#gaee791c36a15344b9e57edae160c86615">mpack_reader_t</a> *&#160;</td>
          <td class="paramname"><em>reader</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a string with the given total maximum size (including space for a null-terminator), allocates storage for it, ensures it is valid UTF-8 with no null-bytes, and adds a null-terminator at the end. You assume ownership of the returned pointer if reading succeeds.</p>
<p>The length in bytes of the string, not including the null-terminator, will be written to size.</p>
<p>This does not accept any UTF-8 variant such as Modified UTF-8, CESU-8 or WTF-8. Only pure UTF-8 is allowed, but without the NUL character, since it cannot be represented in a null-terminated string.</p>
<p>The allocated string must be freed with <a class="el" href="group__config.html#ga298d7c2e4093bcfe361088df9e35956a">MPACK_FREE()</a> (or simply free() if MPack's allocator hasn't been customized.) if you want a null-terminator.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_too_big</td><td>If the string plus null-terminator is larger than the given maxsize. </td></tr>
    <tr><td class="paramname">mpack_error_type</td><td>If the value is not a string or contains invalid UTF-8 or a null byte. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__expect_html_ga65a2a909774f3205887ae446ea4089f0"><div class="ttname"><a href="group__expect.html#ga65a2a909774f3205887ae446ea4089f0">mpack_expect_enum</a></div><div class="ttdeci">size_t mpack_expect_enum(mpack_reader_t *reader, const char *strings[], size_t count)</div></div>
<div class="ttc" id="agroup__expect_html_ga5763a0063111ffdfe8f193fb42e7fea4"><div class="ttname"><a href="group__expect.html#ga5763a0063111ffdfe8f193fb42e7fea4">mpack_expect_enum_optional</a></div><div class="ttdeci">size_t mpack_expect_enum_optional(mpack_reader_t *reader, const char *strings[], size_t count)</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
