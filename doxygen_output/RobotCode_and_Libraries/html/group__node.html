<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>NewRobotCode/WPILIBC(v2022.3.1): Node API</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ORION.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">NewRobotCode/WPILIBC(v2022.3.1)
   &#160;<span id="projectnumber">v2022.0.0.28</span>
   </div>
   <div id="projectbrief">FRC 2022 Robot Code for Team #7464 - ORION</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('group__node.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a>  </div>
  <div class="headertitle">
<div class="title">Node API</div>  </div>
</div><!--header-->
<div class="contents">

<p>The MPack Node API allows you to parse a chunk of MessagePack into a dynamically typed data structure, providing random access to the parsed data.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga08f46371c0c59a2e4dd7bdf1891fb3cb"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a></td></tr>
<tr class="separator:ga08f46371c0c59a2e4dd7bdf1891fb3cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37218aec593259aed8b28625ff1395fb"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__node.html#ga37218aec593259aed8b28625ff1395fb">mpack_node_data_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga37218aec593259aed8b28625ff1395fb">mpack_node_data_t</a></td></tr>
<tr class="separator:ga37218aec593259aed8b28625ff1395fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9c76cfdb08042d6412b5c745bca928a7"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a></td></tr>
<tr class="separator:ga9c76cfdb08042d6412b5c745bca928a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga184ff3fbec66290ec72caf0abc8f3594"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga184ff3fbec66290ec72caf0abc8f3594">mpack_tree_error_t</a>) (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="separator:ga184ff3fbec66290ec72caf0abc8f3594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf6d4fc06cb6b20a52b14c374943c0531"><td class="memItemLeft" align="right" valign="top">typedef size_t(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gaf6d4fc06cb6b20a52b14c374943c0531">mpack_tree_read_t</a>) (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, char *<a class="el" href="classbuffer.html">buffer</a>, size_t count)</td></tr>
<tr class="separator:gaf6d4fc06cb6b20a52b14c374943c0531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ca1eb6735624e7d98d64ac77b525c55"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga1ca1eb6735624e7d98d64ac77b525c55">mpack_tree_teardown_t</a>) (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree)</td></tr>
<tr class="separator:ga1ca1eb6735624e7d98d64ac77b525c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Tree Initialization</h2></td></tr>
<tr class="memitem:ga794963a10b26fbd0e1a9bff136a47ee7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga794963a10b26fbd0e1a9bff136a47ee7">mpack_tree_init_data</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, const char *data, size_t length)</td></tr>
<tr class="separator:ga794963a10b26fbd0e1a9bff136a47ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8c3515858a64d762cfbca56f8eb7561c"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga8c3515858a64d762cfbca56f8eb7561c">mpack_tree_init</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, const char *data, size_t length)</td></tr>
<tr class="separator:ga8c3515858a64d762cfbca56f8eb7561c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e42c40a9a8ae59d231e623d180a42d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga3e42c40a9a8ae59d231e623d180a42d8">mpack_tree_init_stream</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, <a class="el" href="group__node.html#gaf6d4fc06cb6b20a52b14c374943c0531">mpack_tree_read_t</a> read_fn, void *context, size_t max_message_size, size_t max_message_nodes)</td></tr>
<tr class="separator:ga3e42c40a9a8ae59d231e623d180a42d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3cb51d3adfadc336a2ac28605a939a83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga3cb51d3adfadc336a2ac28605a939a83">mpack_tree_init_pool</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, const char *data, size_t length, <a class="el" href="group__node.html#ga37218aec593259aed8b28625ff1395fb">mpack_node_data_t</a> *node_pool, size_t node_pool_count)</td></tr>
<tr class="separator:ga3cb51d3adfadc336a2ac28605a939a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8360ae0ff58c0b6fb5c5997297b602c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gad8360ae0ff58c0b6fb5c5997297b602c">mpack_tree_init_error</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="separator:gad8360ae0ff58c0b6fb5c5997297b602c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga06c2d81ce29bf282a1466bd94a207d2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga06c2d81ce29bf282a1466bd94a207d2a">mpack_tree_init_filename</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, const char *filename, size_t max_bytes)</td></tr>
<tr class="separator:ga06c2d81ce29bf282a1466bd94a207d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6461f02643f7e4f320f7020959b8b599"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga6461f02643f7e4f320f7020959b8b599">mpack_tree_init_file</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, const char *filename, size_t max_bytes)</td></tr>
<tr class="separator:ga6461f02643f7e4f320f7020959b8b599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga80458993ae88f7bbb3b26a8fa8ec4a49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga80458993ae88f7bbb3b26a8fa8ec4a49">mpack_tree_init_stdfile</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, FILE *stdfile, size_t max_bytes, bool close_when_done)</td></tr>
<tr class="separator:ga80458993ae88f7bbb3b26a8fa8ec4a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Tree Functions</h2></td></tr>
<tr class="memitem:gafb16075b8f9c7503d15f34b956ba228e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gafb16075b8f9c7503d15f34b956ba228e">mpack_tree_set_limits</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, size_t max_message_size, size_t max_message_nodes)</td></tr>
<tr class="separator:gafb16075b8f9c7503d15f34b956ba228e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92b59a8d5b062df0dcd2386ec5cfe57b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga92b59a8d5b062df0dcd2386ec5cfe57b">mpack_tree_parse</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree)</td></tr>
<tr class="separator:ga92b59a8d5b062df0dcd2386ec5cfe57b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9865c8548cfc3a53cbe82d682fc3e951"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga9865c8548cfc3a53cbe82d682fc3e951">mpack_tree_try_parse</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree)</td></tr>
<tr class="separator:ga9865c8548cfc3a53cbe82d682fc3e951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c49262ce28699d5ec90db09b5fd2eee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga2c49262ce28699d5ec90db09b5fd2eee">mpack_tree_root</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree)</td></tr>
<tr class="separator:ga2c49262ce28699d5ec90db09b5fd2eee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6393f390b84824af11b6809c16f2fb34"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga6393f390b84824af11b6809c16f2fb34">mpack_tree_error</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree)</td></tr>
<tr class="separator:ga6393f390b84824af11b6809c16f2fb34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9a2402b9da984817b0de813562ea8b5"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gab9a2402b9da984817b0de813562ea8b5">mpack_tree_size</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree)</td></tr>
<tr class="separator:gab9a2402b9da984817b0de813562ea8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabf57acbc8356be8fab13a64f78986fdc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gabf57acbc8356be8fab13a64f78986fdc">mpack_tree_destroy</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree)</td></tr>
<tr class="separator:gabf57acbc8356be8fab13a64f78986fdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30b82e7805e17ed96faf51ab272297a6"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga30b82e7805e17ed96faf51ab272297a6">mpack_tree_set_context</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, void *context)</td></tr>
<tr class="separator:ga30b82e7805e17ed96faf51ab272297a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0ad9545f943289e6bd3b06dfa3a7afff"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga0ad9545f943289e6bd3b06dfa3a7afff">mpack_tree_context</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree)</td></tr>
<tr class="separator:ga0ad9545f943289e6bd3b06dfa3a7afff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad67ed9046795fa1ee8e0a646612c6681"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gad67ed9046795fa1ee8e0a646612c6681">mpack_tree_set_error_handler</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, <a class="el" href="group__node.html#ga184ff3fbec66290ec72caf0abc8f3594">mpack_tree_error_t</a> error_fn)</td></tr>
<tr class="separator:gad67ed9046795fa1ee8e0a646612c6681"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8de7daf54555578856535b0b11fe58d1"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga8de7daf54555578856535b0b11fe58d1">mpack_tree_set_teardown</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, <a class="el" href="group__node.html#ga1ca1eb6735624e7d98d64ac77b525c55">mpack_tree_teardown_t</a> teardown)</td></tr>
<tr class="separator:ga8de7daf54555578856535b0b11fe58d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga46fdd2e384e7399f07a600e13962a492"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga46fdd2e384e7399f07a600e13962a492">mpack_tree_flag_error</a> (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="separator:ga46fdd2e384e7399f07a600e13962a492"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Node Core Functions</h2></td></tr>
<tr class="memitem:ga46d2b3688954e32cb81268f982362036"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga46d2b3688954e32cb81268f982362036">mpack_node_flag_error</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td></tr>
<tr class="separator:ga46d2b3688954e32cb81268f982362036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad38b07a6bcb0d2d8999a8e03915c96b1"><td class="memItemLeft" align="right" valign="top">MPACK_INLINE <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gad38b07a6bcb0d2d8999a8e03915c96b1">mpack_node_error</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:gad38b07a6bcb0d2d8999a8e03915c96b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9bafb2aa97ea8ce8f517303329236b2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga008da69ac6b5582a893f2d2ffd37f4ac">mpack_tag_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga9bafb2aa97ea8ce8f517303329236b2c">mpack_node_tag</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga9bafb2aa97ea8ce8f517303329236b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Node Primitive Value Functions</h2></td></tr>
<tr class="memitem:gabf769643817c3d88f98cc40801fba2eb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__common.html#ga22f03cf1240d5a917e1b3e7be8ab327e">mpack_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gabf769643817c3d88f98cc40801fba2eb">mpack_node_type</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:gabf769643817c3d88f98cc40801fba2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0972cac5d44d513bebb5df7093f44ea9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga0972cac5d44d513bebb5df7093f44ea9">mpack_node_is_nil</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga0972cac5d44d513bebb5df7093f44ea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga115411a3ca7b8c9944d68c941427ae4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga115411a3ca7b8c9944d68c941427ae4f">mpack_node_is_missing</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga115411a3ca7b8c9944d68c941427ae4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga42f4b9aebd9d612b1e5073490a4abba4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga42f4b9aebd9d612b1e5073490a4abba4">mpack_node_nil</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga42f4b9aebd9d612b1e5073490a4abba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8ae84a6564a5c78ee30d4baa6fbde982"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga8ae84a6564a5c78ee30d4baa6fbde982">mpack_node_missing</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga8ae84a6564a5c78ee30d4baa6fbde982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad15f3dba3fe1c0b5b7d9ed5d2c34215a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gad15f3dba3fe1c0b5b7d9ed5d2c34215a">mpack_node_bool</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:gad15f3dba3fe1c0b5b7d9ed5d2c34215a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab54c26f5fc03f73b02070a72610c9127"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gab54c26f5fc03f73b02070a72610c9127">mpack_node_true</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:gab54c26f5fc03f73b02070a72610c9127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gabc37f432559b3b4be52e91e66a09f57d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gabc37f432559b3b4be52e91e66a09f57d">mpack_node_false</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:gabc37f432559b3b4be52e91e66a09f57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad54f9c1d4bfdb0ae572782c4307d475f"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gad54f9c1d4bfdb0ae572782c4307d475f">mpack_node_u8</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:gad54f9c1d4bfdb0ae572782c4307d475f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5bc29e58ae03edd0d764eac30b6ab38a"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga5bc29e58ae03edd0d764eac30b6ab38a">mpack_node_i8</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga5bc29e58ae03edd0d764eac30b6ab38a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadcfbddcda8865d49667003bc16d41e42"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gadcfbddcda8865d49667003bc16d41e42">mpack_node_u16</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:gadcfbddcda8865d49667003bc16d41e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafe5d3aa7d76cb528a3dc10024a1eb0d9"><td class="memItemLeft" align="right" valign="top">int16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gafe5d3aa7d76cb528a3dc10024a1eb0d9">mpack_node_i16</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:gafe5d3aa7d76cb528a3dc10024a1eb0d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga996315bf57d89a2a6f5d4e2936ed74e4"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga996315bf57d89a2a6f5d4e2936ed74e4">mpack_node_u32</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga996315bf57d89a2a6f5d4e2936ed74e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0180b62e35f1438807cec5f1dc747f3d"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga0180b62e35f1438807cec5f1dc747f3d">mpack_node_i32</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga0180b62e35f1438807cec5f1dc747f3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3d5e8f4732b9e7db24cf9f4581b13356"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga3d5e8f4732b9e7db24cf9f4581b13356">mpack_node_u64</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga3d5e8f4732b9e7db24cf9f4581b13356"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1364528bea1667a421d39bad3e0453a"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gae1364528bea1667a421d39bad3e0453a">mpack_node_i64</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:gae1364528bea1667a421d39bad3e0453a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga28f422427efed19ce0a292b135a13067"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga28f422427efed19ce0a292b135a13067">mpack_node_uint</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga28f422427efed19ce0a292b135a13067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7beb8942f1d779d6fd688a4db84a3358"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga7beb8942f1d779d6fd688a4db84a3358">mpack_node_int</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga7beb8942f1d779d6fd688a4db84a3358"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga66fed30759650f65e7edaef79b2c73f4"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga66fed30759650f65e7edaef79b2c73f4">mpack_node_float</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga66fed30759650f65e7edaef79b2c73f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga22bfc52e19de4f1b5f9db6a9373cce06"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga22bfc52e19de4f1b5f9db6a9373cce06">mpack_node_double</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga22bfc52e19de4f1b5f9db6a9373cce06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b7dce2bf350091c232cf556ee50ace9"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga2b7dce2bf350091c232cf556ee50ace9">mpack_node_float_strict</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga2b7dce2bf350091c232cf556ee50ace9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74a690ab822846b19baa59f32cba766a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga74a690ab822846b19baa59f32cba766a">mpack_node_double_strict</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga74a690ab822846b19baa59f32cba766a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Node String and Data Functions</h2></td></tr>
<tr class="memitem:gacb8292add714bdf140793a83469d8e9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gacb8292add714bdf140793a83469d8e9f">mpack_node_check_utf8</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:gacb8292add714bdf140793a83469d8e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa4dc121daf1202070c03fd56a5cd4fa8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gaa4dc121daf1202070c03fd56a5cd4fa8">mpack_node_check_utf8_cstr</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:gaa4dc121daf1202070c03fd56a5cd4fa8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadbf34d29aad8496c366614b3fe3145d5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gadbf34d29aad8496c366614b3fe3145d5">mpack_node_bin_size</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:gadbf34d29aad8496c366614b3fe3145d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2c44540f9af1a1a32dc260f6b787bb8c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga2c44540f9af1a1a32dc260f6b787bb8c">mpack_node_data_len</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga2c44540f9af1a1a32dc260f6b787bb8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae8a777b769930bea4e8a11738179ae7e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gae8a777b769930bea4e8a11738179ae7e">mpack_node_strlen</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:gae8a777b769930bea4e8a11738179ae7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9019bed33210791449cd9c594446fc8f"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga9019bed33210791449cd9c594446fc8f">mpack_node_str</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga9019bed33210791449cd9c594446fc8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga41ced2d8bfa19e4d19b0f18306bee140"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga41ced2d8bfa19e4d19b0f18306bee140">mpack_node_data</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga41ced2d8bfa19e4d19b0f18306bee140"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga58c5e2ea0c7d64af033a5e5e6a79b590"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga58c5e2ea0c7d64af033a5e5e6a79b590">mpack_node_bin_data</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga58c5e2ea0c7d64af033a5e5e6a79b590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1133de49c7725d34512e096752be8f33"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga1133de49c7725d34512e096752be8f33">mpack_node_copy_data</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, char *<a class="el" href="classbuffer.html">buffer</a>, size_t bufsize)</td></tr>
<tr class="separator:ga1133de49c7725d34512e096752be8f33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3c572f76b9b6870eaa765e3acb6954c1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga3c572f76b9b6870eaa765e3acb6954c1">mpack_node_copy_utf8</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, char *<a class="el" href="classbuffer.html">buffer</a>, size_t bufsize)</td></tr>
<tr class="separator:ga3c572f76b9b6870eaa765e3acb6954c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf38c3d482a5eb473aa37594ee0ebf593"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gaf38c3d482a5eb473aa37594ee0ebf593">mpack_node_copy_cstr</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, char *<a class="el" href="classbuffer.html">buffer</a>, size_t size)</td></tr>
<tr class="separator:gaf38c3d482a5eb473aa37594ee0ebf593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf89e330244c3266c22bb8ce88f85dd66"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gaf89e330244c3266c22bb8ce88f85dd66">mpack_node_copy_utf8_cstr</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, char *<a class="el" href="classbuffer.html">buffer</a>, size_t size)</td></tr>
<tr class="separator:gaf89e330244c3266c22bb8ce88f85dd66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2799b6fabe286b3a7093c529e61739ef"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga2799b6fabe286b3a7093c529e61739ef">mpack_node_data_alloc</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, size_t maxsize)</td></tr>
<tr class="separator:ga2799b6fabe286b3a7093c529e61739ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d7814632a852596f475994e0f388b99"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga6d7814632a852596f475994e0f388b99">mpack_node_cstr_alloc</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, size_t maxsize)</td></tr>
<tr class="separator:ga6d7814632a852596f475994e0f388b99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa52c0130b46f8e0c8efa9f38079ffd1c"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gaa52c0130b46f8e0c8efa9f38079ffd1c">mpack_node_utf8_cstr_alloc</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, size_t maxsize)</td></tr>
<tr class="separator:gaa52c0130b46f8e0c8efa9f38079ffd1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38538087fb67888dfb77682580fb5086"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga38538087fb67888dfb77682580fb5086">mpack_node_enum</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, const char *strings[], size_t count)</td></tr>
<tr class="separator:ga38538087fb67888dfb77682580fb5086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gada6980d1ebe8433ee525d8919ab179b0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gada6980d1ebe8433ee525d8919ab179b0">mpack_node_enum_optional</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, const char *strings[], size_t count)</td></tr>
<tr class="separator:gada6980d1ebe8433ee525d8919ab179b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Compound Node Functions</h2></td></tr>
<tr class="memitem:ga831f47fdd6223dce326fe0f8ecc943d4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga831f47fdd6223dce326fe0f8ecc943d4">mpack_node_array_length</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga831f47fdd6223dce326fe0f8ecc943d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ec21fe2b75a99dc6c3ca5c6d7528c4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga9ec21fe2b75a99dc6c3ca5c6d7528c4e">mpack_node_array_at</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, size_t index)</td></tr>
<tr class="separator:ga9ec21fe2b75a99dc6c3ca5c6d7528c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga03b7cb69d8648ede7a9d9d018b76b8a7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga03b7cb69d8648ede7a9d9d018b76b8a7">mpack_node_map_count</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node)</td></tr>
<tr class="separator:ga03b7cb69d8648ede7a9d9d018b76b8a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga74e16d4e1723a959ec90365078b9668c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga74e16d4e1723a959ec90365078b9668c">mpack_node_map_key_at</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, size_t index)</td></tr>
<tr class="separator:ga74e16d4e1723a959ec90365078b9668c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga88b570192e47f589bc49cca2e88583b4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga88b570192e47f589bc49cca2e88583b4">mpack_node_map_value_at</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, size_t index)</td></tr>
<tr class="separator:ga88b570192e47f589bc49cca2e88583b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad85dcc667be1797e106fc106346ee828"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gad85dcc667be1797e106fc106346ee828">mpack_node_map_int</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, int64_t num)</td></tr>
<tr class="separator:gad85dcc667be1797e106fc106346ee828"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga107c576a3abc79e7dd0048e8ecdbcffc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga107c576a3abc79e7dd0048e8ecdbcffc">mpack_node_map_int_optional</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, int64_t num)</td></tr>
<tr class="separator:ga107c576a3abc79e7dd0048e8ecdbcffc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab1b0edee199d7a2ed032efe412328a29"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gab1b0edee199d7a2ed032efe412328a29">mpack_node_map_uint</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, uint64_t num)</td></tr>
<tr class="separator:gab1b0edee199d7a2ed032efe412328a29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab11b76ad94a8b758203b3c530af88112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gab11b76ad94a8b758203b3c530af88112">mpack_node_map_uint_optional</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, uint64_t num)</td></tr>
<tr class="separator:gab11b76ad94a8b758203b3c530af88112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae307e6001afd0af57b76e612ec74c1b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gae307e6001afd0af57b76e612ec74c1b3">mpack_node_map_str</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, const char *str, size_t length)</td></tr>
<tr class="separator:gae307e6001afd0af57b76e612ec74c1b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6adb4420a9f506885e65bb54f35909ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga6adb4420a9f506885e65bb54f35909ce">mpack_node_map_str_optional</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, const char *str, size_t length)</td></tr>
<tr class="separator:ga6adb4420a9f506885e65bb54f35909ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6ce515ec366036b1602bafe65a56ef7e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga6ce515ec366036b1602bafe65a56ef7e">mpack_node_map_cstr</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, const char *cstr)</td></tr>
<tr class="separator:ga6ce515ec366036b1602bafe65a56ef7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga349940b9a92f53b8dbdfdab049cc667e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga349940b9a92f53b8dbdfdab049cc667e">mpack_node_map_cstr_optional</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, const char *cstr)</td></tr>
<tr class="separator:ga349940b9a92f53b8dbdfdab049cc667e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf8682cff06a6b350f392d6e9ceaf6d9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#gaf8682cff06a6b350f392d6e9ceaf6d9b">mpack_node_map_contains_int</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, int64_t num)</td></tr>
<tr class="separator:gaf8682cff06a6b350f392d6e9ceaf6d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9ab9e368bbde89763962102bff9933b2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga9ab9e368bbde89763962102bff9933b2">mpack_node_map_contains_uint</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, uint64_t num)</td></tr>
<tr class="separator:ga9ab9e368bbde89763962102bff9933b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5da5d0fcfeae4bc1edb7904fd230f783"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga5da5d0fcfeae4bc1edb7904fd230f783">mpack_node_map_contains_str</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, const char *str, size_t length)</td></tr>
<tr class="separator:ga5da5d0fcfeae4bc1edb7904fd230f783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1be7c8845cff656408450ca31c3c3cad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="group__node.html#ga1be7c8845cff656408450ca31c3c3cad">mpack_node_map_contains_cstr</a> (<a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> node, const char *cstr)</td></tr>
<tr class="separator:ga1be7c8845cff656408450ca31c3c3cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<p>The MPack Node API allows you to parse a chunk of MessagePack into a dynamically typed data structure, providing random access to the parsed data. </p>
<p>See docs/node.md for examples. </p>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga37218aec593259aed8b28625ff1395fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga37218aec593259aed8b28625ff1395fb">&#9670;&nbsp;</a></span>mpack_node_data_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__node.html#ga37218aec593259aed8b28625ff1395fb">mpack_node_data_t</a> <a class="el" href="group__node.html#ga37218aec593259aed8b28625ff1395fb">mpack_node_data_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The storage for nodes in an MPack tree.</p>
<p>You only need to use this if you intend to provide your own storage for nodes instead of letting the tree allocate it.</p>
<p><a class="el" href="group__node.html#ga37218aec593259aed8b28625ff1395fb">mpack_node_data_t</a> is 16 bytes on most common architectures (32-bit and 64-bit.) </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l06808">6808</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga08f46371c0c59a2e4dd7bdf1891fb3cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08f46371c0c59a2e4dd7bdf1891fb3cb">&#9670;&nbsp;</a></span>mpack_node_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> <a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A handle to node data in a parsed MPack tree.</p>
<p>Nodes represent either primitive values or compound types. If a node is a compound type, it contains a pointer to its child nodes, or a pointer to its underlying data.</p>
<p>Nodes are immutable.</p>
<dl class="section note"><dt>Note</dt><dd><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> is an opaque reference to the node data, not the node data itself. (It contains pointers to both the node data and the tree.) It is passed by value in the Node API. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l06797">6797</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga184ff3fbec66290ec72caf0abc8f3594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga184ff3fbec66290ec72caf0abc8f3594">&#9670;&nbsp;</a></span>mpack_tree_error_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mpack_tree_error_t) (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> error)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An error handler function to be called when an error is flagged on the tree.</p>
<p>The error handler will only be called once on the first error flagged; any subsequent node reads and errors are ignored, and the tree is permanently in that error state.</p>
<p>MPack is safe against non-local jumps out of error handler callbacks. This means you are allowed to longjmp or throw an exception (in C++, Objective-C, or with SEH) out of this callback.</p>
<p>Bear in mind when using longjmp that local non-volatile variables that have changed are undefined when setjmp() returns, so you can't put the tree on the stack in the same activation frame as the setjmp without declaring it volatile.</p>
<p>You must still eventually destroy the tree. It is not destroyed automatically when an error is flagged. It is safe to destroy the tree within this error callback, but you will either need to perform a non-local jump, or store something in your context to identify that the tree is destroyed since any future accesses to it cause undefined behavior. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l06842">6842</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gaf6d4fc06cb6b20a52b14c374943c0531"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf6d4fc06cb6b20a52b14c374943c0531">&#9670;&nbsp;</a></span>mpack_tree_read_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t(* mpack_tree_read_t) (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree, char *<a class="el" href="classbuffer.html">buffer</a>, size_t count)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The MPack tree's read function. It should fill the buffer with as many bytes as are immediately available up to the given <code>count</code>, returning the number of bytes written to the buffer.</p>
<p>In case of error, it should flag an appropriate error on the reader (usually <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4a6581b50527f1c278f852c91bea70f847">mpack_error_io</a>.)</p>
<p>The blocking or non-blocking behaviour of the read should match whether you are using <a class="el" href="group__node.html#ga92b59a8d5b062df0dcd2386ec5cfe57b">mpack_tree_parse()</a> or <a class="el" href="group__node.html#ga9865c8548cfc3a53cbe82d682fc3e951">mpack_tree_try_parse()</a>.</p>
<p>If you are using <a class="el" href="group__node.html#ga92b59a8d5b062df0dcd2386ec5cfe57b">mpack_tree_parse()</a>, the read should block until at least one byte is read. If you return 0, <a class="el" href="group__node.html#ga92b59a8d5b062df0dcd2386ec5cfe57b">mpack_tree_parse()</a> will raise <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4a6581b50527f1c278f852c91bea70f847">mpack_error_io</a>.</p>
<p>If you are using <a class="el" href="group__node.html#ga9865c8548cfc3a53cbe82d682fc3e951">mpack_tree_try_parse()</a>, the read function can always return 0, and must never block waiting for data (otherwise <a class="el" href="group__node.html#ga9865c8548cfc3a53cbe82d682fc3e951">mpack_tree_try_parse()</a> would be equivalent to <a class="el" href="group__node.html#ga92b59a8d5b062df0dcd2386ec5cfe57b">mpack_tree_parse()</a>.) When you return 0, <a class="el" href="group__node.html#ga9865c8548cfc3a53cbe82d682fc3e951">mpack_tree_try_parse()</a> will return false without flagging an error. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l06865">6865</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga9c76cfdb08042d6412b5c745bca928a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9c76cfdb08042d6412b5c745bca928a7">&#9670;&nbsp;</a></span>mpack_tree_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> <a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An MPack tree parser to parse a blob or stream of MessagePack.</p>
<p>When a message is parsed, the tree contains a single root node which contains all parsed data. The tree and its nodes are immutable. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l06816">6816</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga1ca1eb6735624e7d98d64ac77b525c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1ca1eb6735624e7d98d64ac77b525c55">&#9670;&nbsp;</a></span>mpack_tree_teardown_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* mpack_tree_teardown_t) (<a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *tree)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A teardown function to be called when the tree is destroyed. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l06870">6870</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga9ec21fe2b75a99dc6c3ca5c6d7528c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ec21fe2b75a99dc6c3ca5c6d7528c4e">&#9670;&nbsp;</a></span>mpack_node_array_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_array_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the node in the given array at the given index. If the node is not an array, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised and a nil node is returned. If the given index is out of bounds, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ae53cbed8fcc42915d71ae37d121b22e8">mpack_error_data</a> is raised and a nil node is returned. </p>

</div>
</div>
<a id="ga831f47fdd6223dce326fe0f8ecc943d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga831f47fdd6223dce326fe0f8ecc943d4">&#9670;&nbsp;</a></span>mpack_node_array_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_node_array_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of the given array node. Raises mpack_error_type and returns 0 if the given node is not an array. </p>

</div>
</div>
<a id="ga58c5e2ea0c7d64af033a5e5e6a79b590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga58c5e2ea0c7d64af033a5e5e6a79b590">&#9670;&nbsp;</a></span>mpack_node_bin_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* mpack_node_bin_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the data contained by this bin node.</p>
<p>The pointer is valid as long as the data backing the tree is valid.</p>
<p>If this node is not a bin, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised and <code>NULL</code> is returned. </p>

</div>
</div>
<a id="gadbf34d29aad8496c366614b3fe3145d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadbf34d29aad8496c366614b3fe3145d5">&#9670;&nbsp;</a></span>mpack_node_bin_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_node_bin_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of bytes in the given bin node.</p>
<p>This returns zero if the tree is in an error state.</p>
<p>If this node is not a bin, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised and zero is returned. </p>

</div>
</div>
<a id="gad15f3dba3fe1c0b5b7d9ed5d2c34215a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad15f3dba3fe1c0b5b7d9ed5d2c34215a">&#9670;&nbsp;</a></span>mpack_node_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_node_bool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the bool value of the node. If this node is not of the correct type, false is returned and mpack_error_type is raised. </p>

</div>
</div>
<a id="gacb8292add714bdf140793a83469d8e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gacb8292add714bdf140793a83469d8e9f">&#9670;&nbsp;</a></span>mpack_node_check_utf8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_check_utf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that the given node contains a valid UTF-8 string.</p>
<p>If the string is invalid, this flags an error, which would cause subsequent calls to <a class="el" href="group__node.html#ga9019bed33210791449cd9c594446fc8f">mpack_node_str()</a> to return NULL and <a class="el" href="group__node.html#gae8a777b769930bea4e8a11738179ae7e">mpack_node_strlen()</a> to return zero. So you can check the node for error immediately after calling this, or you can call those functions to use the data anyway and check for errors later.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If this node is not a string or does not contain valid UTF-8.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The string node to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__node.html#ga9019bed33210791449cd9c594446fc8f">mpack_node_str()</a> </dd>
<dd>
<a class="el" href="group__node.html#gae8a777b769930bea4e8a11738179ae7e">mpack_node_strlen()</a> </dd></dl>

</div>
</div>
<a id="gaa4dc121daf1202070c03fd56a5cd4fa8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa4dc121daf1202070c03fd56a5cd4fa8">&#9670;&nbsp;</a></span>mpack_node_check_utf8_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_check_utf8_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that the given node contains a valid UTF-8 string with no NUL bytes.</p>
<p>This does not check that the string has a null-terminator! It only checks whether the string could safely be represented as a C-string by appending a null-terminator. (If the string does already contain a null-terminator, this will flag an error.)</p>
<p>This is performed automatically by other UTF-8 cstr helper functions. Only call this if you will do something else with the data directly, but you still want to ensure it will be valid as a UTF-8 C-string.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If this node is not a string, does not contain valid UTF-8, or contains a NUL byte.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The string node to test</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__node.html#ga9019bed33210791449cd9c594446fc8f">mpack_node_str()</a> </dd>
<dd>
<a class="el" href="group__node.html#gae8a777b769930bea4e8a11738179ae7e">mpack_node_strlen()</a> </dd>
<dd>
<a class="el" href="group__node.html#gaf89e330244c3266c22bb8ce88f85dd66">mpack_node_copy_utf8_cstr()</a> </dd>
<dd>
<a class="el" href="group__node.html#gaa52c0130b46f8e0c8efa9f38079ffd1c">mpack_node_utf8_cstr_alloc()</a> </dd></dl>

</div>
</div>
<a id="gaf38c3d482a5eb473aa37594ee0ebf593"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf38c3d482a5eb473aa37594ee0ebf593">&#9670;&nbsp;</a></span>mpack_node_copy_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_copy_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that the given node contains a string with no NUL bytes, copies the string into the given buffer, and adds a null terminator.</p>
<p>If this node is not of a string type, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised. If the string does not fit, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ae53cbed8fcc42915d71ae37d121b22e8">mpack_error_data</a> is raised.</p>
<p>If any error occurs, the buffer will contain an empty null-terminated string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The string node from which to copy data </td></tr>
    <tr><td class="paramname">buffer</td><td>A buffer in which to copy the node's string </td></tr>
    <tr><td class="paramname">size</td><td>The size of the given buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga1133de49c7725d34512e096752be8f33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1133de49c7725d34512e096752be8f33">&#9670;&nbsp;</a></span>mpack_node_copy_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_node_copy_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Copies the bytes contained by this node into the given buffer, returning the number of bytes in the node.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If this node is not a str, bin or ext type </td></tr>
    <tr><td class="paramname">mpack_error_too_big</td><td>If the string does not fit in the given buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The string node from which to copy data </td></tr>
    <tr><td class="paramname">buffer</td><td>A buffer in which to copy the node's bytes </td></tr>
    <tr><td class="paramname">bufsize</td><td>The size of the given buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the node, or zero if an error occurs. </dd></dl>

</div>
</div>
<a id="ga3c572f76b9b6870eaa765e3acb6954c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3c572f76b9b6870eaa765e3acb6954c1">&#9670;&nbsp;</a></span>mpack_node_copy_utf8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_node_copy_utf8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bufsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that the given node contains a valid UTF-8 string and copies the string into the given buffer, returning the number of bytes in the string.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If this node is not a string </td></tr>
    <tr><td class="paramname">mpack_error_too_big</td><td>If the string does not fit in the given buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The string node from which to copy data </td></tr>
    <tr><td class="paramname">buffer</td><td>A buffer in which to copy the node's bytes </td></tr>
    <tr><td class="paramname">bufsize</td><td>The size of the given buffer</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The number of bytes in the node, or zero if an error occurs. </dd></dl>

</div>
</div>
<a id="gaf89e330244c3266c22bb8ce88f85dd66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf89e330244c3266c22bb8ce88f85dd66">&#9670;&nbsp;</a></span>mpack_node_copy_utf8_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_copy_utf8_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that the given node contains a valid UTF-8 string with no NUL bytes, copies the string into the given buffer, and adds a null terminator.</p>
<p>If this node is not of a string type, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised. If the string does not fit, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ae53cbed8fcc42915d71ae37d121b22e8">mpack_error_data</a> is raised.</p>
<p>If any error occurs, the buffer will contain an empty null-terminated string.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The string node from which to copy data </td></tr>
    <tr><td class="paramname">buffer</td><td>A buffer in which to copy the node's string </td></tr>
    <tr><td class="paramname">size</td><td>The size of the given buffer </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga6d7814632a852596f475994e0f388b99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6d7814632a852596f475994e0f388b99">&#9670;&nbsp;</a></span>mpack_node_cstr_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_node_cstr_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a new null-terminated string using <a class="el" href="group__config.html#gaae24f07943fceb85820a88fa72373482">MPACK_MALLOC()</a> with the string contained by this node.</p>
<p>The allocated string must be freed with <a class="el" href="group__config.html#ga298d7c2e4093bcfe361088df9e35956a">MPACK_FREE()</a> (or simply free() if MPack's allocator hasn't been customized.)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If this node is not a string or contains NUL bytes </td></tr>
    <tr><td class="paramname">mpack_error_too_big</td><td>If the size of the string plus null-terminator is larger than the given maximum size </td></tr>
    <tr><td class="paramname">mpack_error_memory</td><td>If an allocation failure occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node from which to allocate and copy string data </td></tr>
    <tr><td class="paramname">maxsize</td><td>The maximum size to allocate, including the null-terminator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated string, or NULL if any error occurs. </dd></dl>

</div>
</div>
<a id="ga41ced2d8bfa19e4d19b0f18306bee140"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga41ced2d8bfa19e4d19b0f18306bee140">&#9670;&nbsp;</a></span>mpack_node_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* mpack_node_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the data contained by this node.</p>
<dl class="section note"><dt>Note</dt><dd>Strings are not null-terminated! Use one of the cstr functions to get a null-terminated string.</dd></dl>
<p>The pointer is valid as long as the data backing the tree is valid.</p>
<p>If this node is not of a str, bin or map, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised, and <code>NULL</code> is returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__node.html#gaf38c3d482a5eb473aa37594ee0ebf593">mpack_node_copy_cstr()</a> </dd>
<dd>
<a class="el" href="group__node.html#ga6d7814632a852596f475994e0f388b99">mpack_node_cstr_alloc()</a> </dd>
<dd>
<a class="el" href="group__node.html#gaa52c0130b46f8e0c8efa9f38079ffd1c">mpack_node_utf8_cstr_alloc()</a> </dd></dl>

</div>
</div>
<a id="ga2799b6fabe286b3a7093c529e61739ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2799b6fabe286b3a7093c529e61739ef">&#9670;&nbsp;</a></span>mpack_node_data_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_node_data_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a new chunk of data using <a class="el" href="group__config.html#gaae24f07943fceb85820a88fa72373482">MPACK_MALLOC()</a> with the bytes contained by this node.</p>
<p>The allocated data must be freed with <a class="el" href="group__config.html#ga298d7c2e4093bcfe361088df9e35956a">MPACK_FREE()</a> (or simply free() if MPack's allocator hasn't been customized.)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If this node is not a str, bin or ext type </td></tr>
    <tr><td class="paramname">mpack_error_too_big</td><td>If the size of the data is larger than the given maximum size </td></tr>
    <tr><td class="paramname">mpack_error_memory</td><td>If an allocation failure occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node from which to allocate and copy data </td></tr>
    <tr><td class="paramname">maxsize</td><td>The maximum size to allocate</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated data, or NULL if any error occurs. </dd></dl>

</div>
</div>
<a id="ga2c44540f9af1a1a32dc260f6b787bb8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c44540f9af1a1a32dc260f6b787bb8c">&#9670;&nbsp;</a></span>mpack_node_data_len()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_node_data_len </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of the given str, bin or ext node.</p>
<p>This returns zero if the tree is in an error state.</p>
<p>If this node is not a str, bin or map, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised and zero is returned. </p>

</div>
</div>
<a id="ga22bfc52e19de4f1b5f9db6a9373cce06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga22bfc52e19de4f1b5f9db6a9373cce06">&#9670;&nbsp;</a></span>mpack_node_double()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mpack_node_double </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the double value of the node. The underlying value can be an integer, float or double; the value is converted to a double.</p>
<dl class="section note"><dt>Note</dt><dd>Reading a very large integer with this function can incur a loss of precision.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga74a690ab822846b19baa59f32cba766a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74a690ab822846b19baa59f32cba766a">&#9670;&nbsp;</a></span>mpack_node_double_strict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double mpack_node_double_strict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the double value of the node. The underlying value must be a float or double, not an integer. This ensures no loss of precision can occur.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float or double. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga38538087fb67888dfb77682580fb5086"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38538087fb67888dfb77682580fb5086">&#9670;&nbsp;</a></span>mpack_node_enum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_node_enum </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>strings</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the given string array for a string matching the given node and returns its index.</p>
<p>If the node does not match any of the given strings, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is flagged. Use <a class="el" href="group__node.html#gada6980d1ebe8433ee525d8919ab179b0">mpack_node_enum_optional()</a> if you want to allow values other than the given strings.</p>
<p>If any error occurs or if the tree is in an error state, <em>count</em> is returned.</p>
<p>This can be used to quickly parse a string into an enum when the enum values range from 0 to <em>count-1</em>. If the last value in the enum is a special "count" value, it can be passed as the count, and the return value can be cast directly to the enum type.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>           { APPLE ,  BANANA ,  ORANGE , COUNT} fruit_t;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* fruits[] = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>};</div>
<div class="line"> </div>
<div class="line">fruit_t fruit = (fruit_t)<a class="code" href="group__node.html#ga38538087fb67888dfb77682580fb5086">mpack_node_enum</a>(node, fruits, COUNT);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node </td></tr>
    <tr><td class="paramname">strings</td><td>An array of expected strings of length count </td></tr>
    <tr><td class="paramname">count</td><td>The number of strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the matched string, or <em>count</em> in case of error </dd></dl>

</div>
</div>
<a id="gada6980d1ebe8433ee525d8919ab179b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gada6980d1ebe8433ee525d8919ab179b0">&#9670;&nbsp;</a></span>mpack_node_enum_optional()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_node_enum_optional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>strings</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Searches the given string array for a string matching the given node, returning its index or <em>count</em> if no strings match.</p>
<p>If the value is not a string, or it does not match any of the given strings, <em>count</em> is returned and no error is flagged.</p>
<p>If any error occurs or if the tree is in an error state, <em>count</em> is returned.</p>
<p>This can be used to quickly parse a string into an enum when the enum values range from 0 to <em>count-1</em>. If the last value in the enum is a special "count" value, it can be passed as the count, and the return value can be cast directly to the enum type.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span>           { APPLE ,  BANANA ,  ORANGE , COUNT} fruit_t;</div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">char</span>* fruits[] = {<span class="stringliteral">&quot;apple&quot;</span>, <span class="stringliteral">&quot;banana&quot;</span>, <span class="stringliteral">&quot;orange&quot;</span>};</div>
<div class="line"> </div>
<div class="line">fruit_t fruit = (fruit_t)<a class="code" href="group__node.html#gada6980d1ebe8433ee525d8919ab179b0">mpack_node_enum_optional</a>(node, fruits, COUNT);</div>
</div><!-- fragment --><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node </td></tr>
    <tr><td class="paramname">strings</td><td>An array of expected strings of length count </td></tr>
    <tr><td class="paramname">count</td><td>The number of strings </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The index of the matched string, or <em>count</em> in case of error </dd></dl>

</div>
</div>
<a id="gad38b07a6bcb0d2d8999a8e03915c96b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad38b07a6bcb0d2d8999a8e03915c96b1">&#9670;&nbsp;</a></span>mpack_node_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> mpack_node_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the error state of the node's tree. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l07353">7353</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gabc37f432559b3b4be52e91e66a09f57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabc37f432559b3b4be52e91e66a09f57d">&#9670;&nbsp;</a></span>mpack_node_false()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_false </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the given node is of bool type with value false, raising mpack_error_type otherwise. </p>

</div>
</div>
<a id="ga46d2b3688954e32cb81268f982362036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46d2b3688954e32cb81268f982362036">&#9670;&nbsp;</a></span>mpack_node_flag_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_flag_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Places the node's tree in the given error state, calling the error callback if one is set.</p>
<p>This allows you to externally flag errors, for example if you are validating data as you read it.</p>
<p>If the tree is already in an error state, this call is ignored and no error callback is called. </p>

</div>
</div>
<a id="ga66fed30759650f65e7edaef79b2c73f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga66fed30759650f65e7edaef79b2c73f4">&#9670;&nbsp;</a></span>mpack_node_float()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mpack_node_float </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the float value of the node. The underlying value can be an integer, float or double; the value is converted to a float.</p>
<dl class="section note"><dt>Note</dt><dd>Reading a double or a large integer with this function can incur a loss of precision.</dd></dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float, double or integer. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga2b7dce2bf350091c232cf556ee50ace9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b7dce2bf350091c232cf556ee50ace9">&#9670;&nbsp;</a></span>mpack_node_float_strict()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float mpack_node_float_strict </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the float value of the node. The underlying value must be a float, not a double or an integer. This ensures no loss of precision can occur.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the underlying value is not a float. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gafe5d3aa7d76cb528a3dc10024a1eb0d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafe5d3aa7d76cb528a3dc10024a1eb0d9">&#9670;&nbsp;</a></span>mpack_node_i16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int16_t mpack_node_i16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the 16-bit signed value of the node. If this node is not of a compatible type, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised and zero is returned. </p>

</div>
</div>
<a id="ga0180b62e35f1438807cec5f1dc747f3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0180b62e35f1438807cec5f1dc747f3d">&#9670;&nbsp;</a></span>mpack_node_i32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t mpack_node_i32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the 32-bit signed value of the node. If this node is not of a compatible type, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised and zero is returned. </p>

</div>
</div>
<a id="gae1364528bea1667a421d39bad3e0453a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1364528bea1667a421d39bad3e0453a">&#9670;&nbsp;</a></span>mpack_node_i64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t mpack_node_i64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the 64-bit signed value of the node. If this node is not of a compatible type, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised and zero is returned. </p>

</div>
</div>
<a id="ga5bc29e58ae03edd0d764eac30b6ab38a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5bc29e58ae03edd0d764eac30b6ab38a">&#9670;&nbsp;</a></span>mpack_node_i8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t mpack_node_i8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the 8-bit signed value of the node. If this node is not of a compatible type, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised and zero is returned. </p>

</div>
</div>
<a id="ga7beb8942f1d779d6fd688a4db84a3358"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7beb8942f1d779d6fd688a4db84a3358">&#9670;&nbsp;</a></span>mpack_node_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int mpack_node_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the int value of the node.</p>
<p>Returns zero if an error occurs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not an integer type or does not fit in the range of an int </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga115411a3ca7b8c9944d68c941427ae4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga115411a3ca7b8c9944d68c941427ae4f">&#9670;&nbsp;</a></span>mpack_node_is_missing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_node_is_missing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the given node handle indicates a missing node; false otherwise.</p>
<p>To ensure that a node is missing and flag an error otherwise, use <a class="el" href="group__node.html#ga8ae84a6564a5c78ee30d4baa6fbde982">mpack_node_missing()</a>. </p>

</div>
</div>
<a id="ga0972cac5d44d513bebb5df7093f44ea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0972cac5d44d513bebb5df7093f44ea9">&#9670;&nbsp;</a></span>mpack_node_is_nil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_node_is_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the given node is a nil node; false otherwise.</p>
<p>To ensure that a node is nil and flag an error otherwise, use <a class="el" href="group__node.html#ga42f4b9aebd9d612b1e5073490a4abba4">mpack_node_nil()</a>. </p>

</div>
</div>
<a id="ga1be7c8845cff656408450ca31c3c3cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1be7c8845cff656408450ca31c3c3cad">&#9670;&nbsp;</a></span>mpack_node_map_contains_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_node_map_contains_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the given node map contains exactly one entry with the given null-terminated string key.</p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node contains more than one entry with the given key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaf8682cff06a6b350f392d6e9ceaf6d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaf8682cff06a6b350f392d6e9ceaf6d9b">&#9670;&nbsp;</a></span>mpack_node_map_contains_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_node_map_contains_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the given node map contains exactly one entry with the given integer key.</p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node contains more than one entry with the given key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga5da5d0fcfeae4bc1edb7904fd230f783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga5da5d0fcfeae4bc1edb7904fd230f783">&#9670;&nbsp;</a></span>mpack_node_map_contains_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_node_map_contains_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the given node map contains exactly one entry with the given string key.</p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node contains more than one entry with the given key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga9ab9e368bbde89763962102bff9933b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9ab9e368bbde89763962102bff9933b2">&#9670;&nbsp;</a></span>mpack_node_map_contains_uint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_node_map_contains_uint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the given node map contains exactly one entry with the given unsigned integer key.</p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node contains more than one entry with the given key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga03b7cb69d8648ede7a9d9d018b76b8a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga03b7cb69d8648ede7a9d9d018b76b8a7">&#9670;&nbsp;</a></span>mpack_node_map_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_node_map_count </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the number of key/value pairs in the given map node. Raises mpack_error_type and returns 0 if the given node is not a map. </p>

</div>
</div>
<a id="ga6ce515ec366036b1602bafe65a56ef7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6ce515ec366036b1602bafe65a56ef7e">&#9670;&nbsp;</a></span>mpack_node_map_cstr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_cstr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value node in the given map for the given null-terminated string key.</p>
<p>The key must exist within the map. Use <a class="el" href="group__node.html#ga349940b9a92f53b8dbdfdab049cc667e">mpack_node_map_cstr_optional()</a> to check for optional keys.</p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node does not contain exactly one entry with the given key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value node for the given key, or a nil node in case of error </dd></dl>

</div>
</div>
<a id="ga349940b9a92f53b8dbdfdab049cc667e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga349940b9a92f53b8dbdfdab049cc667e">&#9670;&nbsp;</a></span>mpack_node_map_cstr_optional()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_cstr_optional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>cstr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value node in the given map for the given null-terminated string key, or a missing node if the map does not contain the given key.</p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node contains more than one entry with the given key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value node for the given key, or a missing node if the key does not exist, or a nil node in case of error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__node.html#ga115411a3ca7b8c9944d68c941427ae4f">mpack_node_is_missing()</a> </dd></dl>

</div>
</div>
<a id="gad85dcc667be1797e106fc106346ee828"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad85dcc667be1797e106fc106346ee828">&#9670;&nbsp;</a></span>mpack_node_map_int()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_int </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value node in the given map for the given integer key.</p>
<p>The key must exist within the map. Use <a class="el" href="group__node.html#ga107c576a3abc79e7dd0048e8ecdbcffc">mpack_node_map_int_optional()</a> to check for optional keys.</p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node does not contain exactly one entry with the given key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value node for the given key, or a nil node in case of error </dd></dl>

</div>
</div>
<a id="ga107c576a3abc79e7dd0048e8ecdbcffc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga107c576a3abc79e7dd0048e8ecdbcffc">&#9670;&nbsp;</a></span>mpack_node_map_int_optional()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_int_optional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value node in the given map for the given integer key, or a missing node if the map does not contain the given key.</p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node contains more than one entry with the given key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value node for the given key, or a missing node if the key does not exist, or a nil node in case of error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__node.html#ga115411a3ca7b8c9944d68c941427ae4f">mpack_node_is_missing()</a> </dd></dl>

</div>
</div>
<a id="ga74e16d4e1723a959ec90365078b9668c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga74e16d4e1723a959ec90365078b9668c">&#9670;&nbsp;</a></span>mpack_node_map_key_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_key_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the key node in the given map at the given index.</p>
<p>A nil node is returned in case of error.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>if the given index is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gae307e6001afd0af57b76e612ec74c1b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae307e6001afd0af57b76e612ec74c1b3">&#9670;&nbsp;</a></span>mpack_node_map_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value node in the given map for the given string key.</p>
<p>The key must exist within the map. Use <a class="el" href="group__node.html#ga6adb4420a9f506885e65bb54f35909ce">mpack_node_map_str_optional()</a> to check for optional keys.</p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node does not contain exactly one entry with the given key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value node for the given key, or a nil node in case of error </dd></dl>

</div>
</div>
<a id="ga6adb4420a9f506885e65bb54f35909ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6adb4420a9f506885e65bb54f35909ce">&#9670;&nbsp;</a></span>mpack_node_map_str_optional()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_str_optional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value node in the given map for the given string key, or a missing node if the map does not contain the given key.</p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node contains more than one entry with the given key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value node for the given key, or a missing node if the key does not exist, or a nil node in case of error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__node.html#ga115411a3ca7b8c9944d68c941427ae4f">mpack_node_is_missing()</a> </dd></dl>

</div>
</div>
<a id="gab1b0edee199d7a2ed032efe412328a29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab1b0edee199d7a2ed032efe412328a29">&#9670;&nbsp;</a></span>mpack_node_map_uint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_uint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value node in the given map for the given unsigned integer key.</p>
<p>The key must exist within the map. Use <a class="el" href="group__node.html#gab11b76ad94a8b758203b3c530af88112">mpack_node_map_uint_optional()</a> to check for optional keys.</p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node does not contain exactly one entry with the given key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value node for the given key, or a nil node in case of error </dd></dl>

</div>
</div>
<a id="gab11b76ad94a8b758203b3c530af88112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab11b76ad94a8b758203b3c530af88112">&#9670;&nbsp;</a></span>mpack_node_map_uint_optional()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_uint_optional </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value node in the given map for the given unsigned integer key, or a missing node if the map does not contain the given key.</p>
<p>The key must be unique. An error is flagged if the node has multiple entries with the given key.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>If the node contains more than one entry with the given key</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value node for the given key, or a missing node if the key does not exist, or a nil node in case of error</dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__node.html#ga115411a3ca7b8c9944d68c941427ae4f">mpack_node_is_missing()</a> </dd></dl>

</div>
</div>
<a id="ga88b570192e47f589bc49cca2e88583b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga88b570192e47f589bc49cca2e88583b4">&#9670;&nbsp;</a></span>mpack_node_map_value_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_node_map_value_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the value node in the given map at the given index.</p>
<p>A nil node is returned in case of error.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>if the node is not a map </td></tr>
    <tr><td class="paramname">mpack_error_data</td><td>if the given index is out of bounds </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8ae84a6564a5c78ee30d4baa6fbde982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8ae84a6564a5c78ee30d4baa6fbde982">&#9670;&nbsp;</a></span>mpack_node_missing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_missing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that the given node indicates a missing node, raising <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> otherwise.</p>
<p>Use <a class="el" href="group__node.html#ga115411a3ca7b8c9944d68c941427ae4f">mpack_node_is_missing()</a> to return whether the node is missing. </p>

</div>
</div>
<a id="ga42f4b9aebd9d612b1e5073490a4abba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga42f4b9aebd9d612b1e5073490a4abba4">&#9670;&nbsp;</a></span>mpack_node_nil()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_nil </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks that the given node is of nil type, raising <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> otherwise.</p>
<p>Use <a class="el" href="group__node.html#ga0972cac5d44d513bebb5df7093f44ea9">mpack_node_is_nil()</a> to return whether the node is nil. </p>

</div>
</div>
<a id="ga9019bed33210791449cd9c594446fc8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9019bed33210791449cd9c594446fc8f">&#9670;&nbsp;</a></span>mpack_node_str()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* mpack_node_str </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pointer to the data contained by this node, ensuring the node is a string.</p>
<dl class="section warning"><dt>Warning</dt><dd>Strings are not null-terminated! Use one of the cstr functions to get a null-terminated string.</dd></dl>
<p>The pointer is valid as long as the data backing the tree is valid.</p>
<p>If this node is not a string, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised and <code>NULL</code> is returned.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__node.html#gaf38c3d482a5eb473aa37594ee0ebf593">mpack_node_copy_cstr()</a> </dd>
<dd>
<a class="el" href="group__node.html#ga6d7814632a852596f475994e0f388b99">mpack_node_cstr_alloc()</a> </dd>
<dd>
<a class="el" href="group__node.html#gaa52c0130b46f8e0c8efa9f38079ffd1c">mpack_node_utf8_cstr_alloc()</a> </dd></dl>

</div>
</div>
<a id="gae8a777b769930bea4e8a11738179ae7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae8a777b769930bea4e8a11738179ae7e">&#9670;&nbsp;</a></span>mpack_node_strlen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t mpack_node_strlen </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length in bytes of the given string node. This does not include any null-terminator.</p>
<p>This returns zero if the tree is in an error state.</p>
<p>If this node is not a str, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised and zero is returned. </p>

</div>
</div>
<a id="ga9bafb2aa97ea8ce8f517303329236b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9bafb2aa97ea8ce8f517303329236b2c">&#9670;&nbsp;</a></span>mpack_node_tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga008da69ac6b5582a893f2d2ffd37f4ac">mpack_tag_t</a> mpack_node_tag </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a tag describing the given node, or a nil tag if the tree is in an error state. </p>

</div>
</div>
<a id="gab54c26f5fc03f73b02070a72610c9127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab54c26f5fc03f73b02070a72610c9127">&#9670;&nbsp;</a></span>mpack_node_true()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_node_true </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Checks if the given node is of bool type with value true, raising mpack_error_type otherwise. </p>

</div>
</div>
<a id="gabf769643817c3d88f98cc40801fba2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf769643817c3d88f98cc40801fba2eb">&#9670;&nbsp;</a></span>mpack_node_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga22f03cf1240d5a917e1b3e7be8ab327e">mpack_type_t</a> mpack_node_type </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the type of the node. </p>

</div>
</div>
<a id="gadcfbddcda8865d49667003bc16d41e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadcfbddcda8865d49667003bc16d41e42">&#9670;&nbsp;</a></span>mpack_node_u16()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t mpack_node_u16 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the 16-bit unsigned value of the node. If this node is not of a compatible type, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised and zero is returned. </p>

</div>
</div>
<a id="ga996315bf57d89a2a6f5d4e2936ed74e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga996315bf57d89a2a6f5d4e2936ed74e4">&#9670;&nbsp;</a></span>mpack_node_u32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t mpack_node_u32 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the 32-bit unsigned value of the node. If this node is not of a compatible type, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised and zero is returned. </p>

</div>
</div>
<a id="ga3d5e8f4732b9e7db24cf9f4581b13356"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3d5e8f4732b9e7db24cf9f4581b13356">&#9670;&nbsp;</a></span>mpack_node_u64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t mpack_node_u64 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the 64-bit unsigned value of the node. If this node is not of a compatible type, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised, and zero is returned. </p>

</div>
</div>
<a id="gad54f9c1d4bfdb0ae572782c4307d475f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad54f9c1d4bfdb0ae572782c4307d475f">&#9670;&nbsp;</a></span>mpack_node_u8()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t mpack_node_u8 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the 8-bit unsigned value of the node. If this node is not of a compatible type, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4ac91d0dcefbb9c7b9f41403bbc674aef2">mpack_error_type</a> is raised and zero is returned. </p>

</div>
</div>
<a id="ga28f422427efed19ce0a292b135a13067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga28f422427efed19ce0a292b135a13067">&#9670;&nbsp;</a></span>mpack_node_uint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int mpack_node_uint </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the unsigned int value of the node.</p>
<p>Returns zero if an error occurs.</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If the node is not an integer type or does not fit in the range of an unsigned int </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="gaa52c0130b46f8e0c8efa9f38079ffd1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gaa52c0130b46f8e0c8efa9f38079ffd1c">&#9670;&nbsp;</a></span>mpack_node_utf8_cstr_alloc()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char* mpack_node_utf8_cstr_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maxsize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allocates a new null-terminated string using <a class="el" href="group__config.html#gaae24f07943fceb85820a88fa72373482">MPACK_MALLOC()</a> with the UTF-8 string contained by this node.</p>
<p>The allocated string must be freed with <a class="el" href="group__config.html#ga298d7c2e4093bcfe361088df9e35956a">MPACK_FREE()</a> (or simply free() if MPack's allocator hasn't been customized.)</p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">mpack_error_type</td><td>If this node is not a string, is not valid UTF-8, or contains NUL bytes </td></tr>
    <tr><td class="paramname">mpack_error_too_big</td><td>If the size of the string plus null-terminator is larger than the given maximum size </td></tr>
    <tr><td class="paramname">mpack_error_memory</td><td>If an allocation failure occurs</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node</td><td>The node from which to allocate and copy string data </td></tr>
    <tr><td class="paramname">maxsize</td><td>The maximum size to allocate, including the null-terminator</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The allocated string, or NULL if any error occurs. </dd></dl>

</div>
</div>
<a id="ga0ad9545f943289e6bd3b06dfa3a7afff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0ad9545f943289e6bd3b06dfa3a7afff">&#9670;&nbsp;</a></span>mpack_tree_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE void* mpack_tree_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the custom context for tree callbacks.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__node.html#ga30b82e7805e17ed96faf51ab272297a6">mpack_tree_set_context</a> </dd>
<dd>
<a class="el" href="group__node.html#ga3e42c40a9a8ae59d231e623d180a42d8">mpack_tree_init_stream</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l07283">7283</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gabf57acbc8356be8fab13a64f78986fdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gabf57acbc8356be8fab13a64f78986fdc">&#9670;&nbsp;</a></span>mpack_tree_destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> mpack_tree_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys the tree. </p>

</div>
</div>
<a id="ga6393f390b84824af11b6809c16f2fb34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6393f390b84824af11b6809c16f2fb34">&#9670;&nbsp;</a></span>mpack_tree_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE <a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a> mpack_tree_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the error state of the tree. </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l07242">7242</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga46fdd2e384e7399f07a600e13962a492"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga46fdd2e384e7399f07a600e13962a492">&#9670;&nbsp;</a></span>mpack_tree_flag_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_tree_flag_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Places the tree in the given error state, calling the error callback if one is set.</p>
<p>This allows you to externally flag errors, for example if you are validating data as you read it.</p>
<p>If the tree is already in an error state, this call is ignored and no error callback is called. </p>

</div>
</div>
<a id="ga8c3515858a64d762cfbca56f8eb7561c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8c3515858a64d762cfbca56f8eb7561c">&#9670;&nbsp;</a></span>mpack_tree_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE void mpack_tree_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deprecated.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000068">Deprecated:</a></b></dt><dd>Renamed to <a class="el" href="group__node.html#ga794963a10b26fbd0e1a9bff136a47ee7">mpack_tree_init_data()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l07059">7059</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga794963a10b26fbd0e1a9bff136a47ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga794963a10b26fbd0e1a9bff136a47ee7">&#9670;&nbsp;</a></span>mpack_tree_init_data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_tree_init_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a tree parser with the given data.</p>
<p>Configure the tree if desired, then call <a class="el" href="group__node.html#ga92b59a8d5b062df0dcd2386ec5cfe57b">mpack_tree_parse()</a> to parse it. The tree will allocate pages of nodes as needed and will free them when destroyed.</p>
<p>The tree must be destroyed with <a class="el" href="group__node.html#gabf57acbc8356be8fab13a64f78986fdc">mpack_tree_destroy()</a>.</p>
<p>Any string or blob data types reference the original data, so the given data pointer must remain valid until after the tree is destroyed. </p>

</div>
</div>
<a id="gad8360ae0ff58c0b6fb5c5997297b602c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad8360ae0ff58c0b6fb5c5997297b602c">&#9670;&nbsp;</a></span>mpack_tree_init_error()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_tree_init_error </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__common.html#ga9d9f282ca4183ab5190e09d04c1f74c4">mpack_error_t</a>&#160;</td>
          <td class="paramname"><em>error</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes an MPack tree directly into an error state. Use this if you are writing a wrapper to another <code>mpack_tree_init*()</code> function which can fail its setup. </p>

</div>
</div>
<a id="ga6461f02643f7e4f320f7020959b8b599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga6461f02643f7e4f320f7020959b8b599">&#9670;&nbsp;</a></span>mpack_tree_init_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE void mpack_tree_init_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Deprecated.</p>
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000069">Deprecated:</a></b></dt><dd>Renamed to <a class="el" href="group__node.html#ga06c2d81ce29bf282a1466bd94a207d2a">mpack_tree_init_filename()</a>. </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l07134">7134</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga06c2d81ce29bf282a1466bd94a207d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga06c2d81ce29bf282a1466bd94a207d2a">&#9670;&nbsp;</a></span>mpack_tree_init_filename()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_tree_init_filename </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a tree to parse the given file. The tree must be destroyed with <a class="el" href="group__node.html#gabf57acbc8356be8fab13a64f78986fdc">mpack_tree_destroy()</a>, even if parsing fails.</p>
<p>The file is opened, loaded fully into memory, and closed before this call returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The tree to initialize </td></tr>
    <tr><td class="paramname">filename</td><td>The filename passed to fopen() to read the file </td></tr>
    <tr><td class="paramname">max_bytes</td><td>The maximum size of file to load, or 0 for unlimited size. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga3cb51d3adfadc336a2ac28605a939a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3cb51d3adfadc336a2ac28605a939a83">&#9670;&nbsp;</a></span>mpack_tree_init_pool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_tree_init_pool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__node.html#ga37218aec593259aed8b28625ff1395fb">mpack_node_data_t</a> *&#160;</td>
          <td class="paramname"><em>node_pool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node_pool_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a tree parser with the given data, using the given node data pool to store the results.</p>
<p>Configure the tree if desired, then call <a class="el" href="group__node.html#ga92b59a8d5b062df0dcd2386ec5cfe57b">mpack_tree_parse()</a> to parse it.</p>
<p>If the data does not fit in the pool, <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4a575cd33925a41fe7c157162b233b8308">mpack_error_too_big</a> will be flagged on the tree.</p>
<p>The tree must be destroyed with <a class="el" href="group__node.html#gabf57acbc8356be8fab13a64f78986fdc">mpack_tree_destroy()</a>, even if parsing fails. </p>

</div>
</div>
<a id="ga80458993ae88f7bbb3b26a8fa8ec4a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga80458993ae88f7bbb3b26a8fa8ec4a49">&#9670;&nbsp;</a></span>mpack_tree_init_stdfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_tree_init_stdfile </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>stdfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_bytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>close_when_done</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a tree to parse the given libc FILE. This can be used to read from stdin, or from a file opened separately.</p>
<p>The tree must be destroyed with <a class="el" href="group__node.html#gabf57acbc8356be8fab13a64f78986fdc">mpack_tree_destroy()</a>, even if parsing fails.</p>
<p>The FILE is fully loaded fully into memory (and closed if requested) before this call returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The tree to initialize. </td></tr>
    <tr><td class="paramname">stdfile</td><td>The FILE. </td></tr>
    <tr><td class="paramname">max_bytes</td><td>The maximum size of file to load, or 0 for unlimited size. </td></tr>
    <tr><td class="paramname">close_when_done</td><td>If true, fclose() will be called on the FILE when it is no longer needed. If false, the file will not be closed when reading is done.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The tree will read all data in the FILE before parsing it. If this is used on stdin, the parser will block until it is closed, even if a complete message has been written to it! </dd></dl>

</div>
</div>
<a id="ga3e42c40a9a8ae59d231e623d180a42d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga3e42c40a9a8ae59d231e623d180a42d8">&#9670;&nbsp;</a></span>mpack_tree_init_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_tree_init_stream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__node.html#gaf6d4fc06cb6b20a52b14c374943c0531">mpack_tree_read_t</a>&#160;</td>
          <td class="paramname"><em>read_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_message_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_message_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes a tree parser from an unbounded stream, or a stream of unknown length.</p>
<p>The parser can be used to read a single message from a stream of unknown length, or multiple messages from an unbounded stream, allowing it to be used for RPC communication. Call <a class="el" href="group__node.html#ga92b59a8d5b062df0dcd2386ec5cfe57b">mpack_tree_parse()</a> to parse a message from a blocking stream, or <a class="el" href="group__node.html#ga9865c8548cfc3a53cbe82d682fc3e951">mpack_tree_try_parse()</a> for a non-blocking stream.</p>
<p>The stream will use a growable internal buffer to store the most recent message, as well as allocated pages of nodes for the parse tree.</p>
<p>Maximum allowances for message size and node count must be specified in this function (since the stream is unbounded.) They can be changed later with <a class="el" href="group__node.html#gafb16075b8f9c7503d15f34b956ba228e">mpack_tree_set_limits()</a>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The tree parser </td></tr>
    <tr><td class="paramname">read_fn</td><td>The read function </td></tr>
    <tr><td class="paramname">context</td><td>The context for the read function </td></tr>
    <tr><td class="paramname">max_message_size</td><td>The maximum size of a message in bytes </td></tr>
    <tr><td class="paramname">max_message_nodes</td><td>The maximum number of nodes per message. See <a class="el" href="group__node.html#ga37218aec593259aed8b28625ff1395fb">mpack_node_data_t</a> for the size of nodes.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__node.html#gaf6d4fc06cb6b20a52b14c374943c0531">mpack_tree_read_t</a> </dd>
<dd>
<a class="el" href="group__reader.html#ga83a8e7c2c40a4d41fc53c6b8d28def54">mpack_reader_context()</a> </dd></dl>

</div>
</div>
<a id="ga92b59a8d5b062df0dcd2386ec5cfe57b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga92b59a8d5b062df0dcd2386ec5cfe57b">&#9670;&nbsp;</a></span>mpack_tree_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_tree_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parses a MessagePack message into a tree of immutable nodes.</p>
<p>If successful, the root node will be available under <a class="el" href="group__node.html#ga2c49262ce28699d5ec90db09b5fd2eee">mpack_tree_root()</a>. If not, an appropriate error will be flagged.</p>
<p>This can be called repeatedly to parse a series of messages from a data source. When this is called, all previous nodes from this tree and their contents (including the root node) are invalidated.</p>
<p>If this is called with a stream (see <a class="el" href="group__node.html#ga3e42c40a9a8ae59d231e623d180a42d8">mpack_tree_init_stream()</a>), the stream must block until data is available. (Otherwise, if this is called on a non-blocking stream, parsing will fail with <a class="el" href="group__common.html#gga9d9f282ca4183ab5190e09d04c1f74c4a6581b50527f1c278f852c91bea70f847">mpack_error_io</a> when the fill function returns 0.)</p>
<p>There is no way to recover a tree in an error state. It must be destroyed. </p>

</div>
</div>
<a id="ga2c49262ce28699d5ec90db09b5fd2eee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2c49262ce28699d5ec90db09b5fd2eee">&#9670;&nbsp;</a></span>mpack_tree_root()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="group__node.html#ga08f46371c0c59a2e4dd7bdf1891fb3cb">mpack_node_t</a> mpack_tree_root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the root node of the tree, if the tree is not in an error state. Returns a nil node otherwise.</p>
<dl class="section warning"><dt>Warning</dt><dd>You must call <a class="el" href="group__node.html#ga92b59a8d5b062df0dcd2386ec5cfe57b">mpack_tree_parse()</a> before calling this. If <a class="el" href="group__node.html#ga92b59a8d5b062df0dcd2386ec5cfe57b">mpack_tree_parse()</a> was never called, the tree will assert. </dd></dl>

</div>
</div>
<a id="ga30b82e7805e17ed96faf51ab272297a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga30b82e7805e17ed96faf51ab272297a6">&#9670;&nbsp;</a></span>mpack_tree_set_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE void mpack_tree_set_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the custom pointer to pass to the tree callbacks, such as teardown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The MPack tree. </td></tr>
    <tr><td class="paramname">context</td><td>User data to pass to the tree callbacks.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__reader.html#ga83a8e7c2c40a4d41fc53c6b8d28def54">mpack_reader_context()</a> </dd></dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l07273">7273</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gad67ed9046795fa1ee8e0a646612c6681"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gad67ed9046795fa1ee8e0a646612c6681">&#9670;&nbsp;</a></span>mpack_tree_set_error_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE void mpack_tree_set_error_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__node.html#ga184ff3fbec66290ec72caf0abc8f3594">mpack_tree_error_t</a>&#160;</td>
          <td class="paramname"><em>error_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the error function to call when an error is flagged on the tree.</p>
<p>This should normally be used with <a class="el" href="group__node.html#ga30b82e7805e17ed96faf51ab272297a6">mpack_tree_set_context()</a> to register a custom pointer to pass to the error function.</p>
<p>See the definition of mpack_tree_error_t for more information about what you can do from an error callback.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__node.html#ga184ff3fbec66290ec72caf0abc8f3594">mpack_tree_error_t</a> </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The MPack tree. </td></tr>
    <tr><td class="paramname">error_fn</td><td>The function to call when an error is flagged on the tree. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l07300">7300</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gafb16075b8f9c7503d15f34b956ba228e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gafb16075b8f9c7503d15f34b956ba228e">&#9670;&nbsp;</a></span>mpack_tree_set_limits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void mpack_tree_set_limits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_message_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_message_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the maximum byte size and maximum number of nodes allowed per message.</p>
<p>The default is SIZE_MAX (no limit) unless <a class="el" href="group__node.html#ga3e42c40a9a8ae59d231e623d180a42d8">mpack_tree_init_stream()</a> is called (where maximums are required.)</p>
<p>If a pool of nodes is used, the node limit is the lesser of this limit and the pool size.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The tree parser </td></tr>
    <tr><td class="paramname">max_message_size</td><td>The maximum size of a message in bytes </td></tr>
    <tr><td class="paramname">max_message_nodes</td><td>The maximum number of nodes per message. See <a class="el" href="group__node.html#ga37218aec593259aed8b28625ff1395fb">mpack_node_data_t</a> for the size of nodes. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ga8de7daf54555578856535b0b11fe58d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8de7daf54555578856535b0b11fe58d1">&#9670;&nbsp;</a></span>mpack_tree_set_teardown()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE void mpack_tree_set_teardown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__node.html#ga1ca1eb6735624e7d98d64ac77b525c55">mpack_tree_teardown_t</a>&#160;</td>
          <td class="paramname"><em>teardown</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the teardown function to call when the tree is destroyed.</p>
<p>This should normally be used with <a class="el" href="group__node.html#ga30b82e7805e17ed96faf51ab272297a6">mpack_tree_set_context()</a> to register a custom pointer to pass to the teardown function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">tree</td><td>The MPack tree. </td></tr>
    <tr><td class="paramname">teardown</td><td>The function to call when the tree is destroyed. </td></tr>
  </table>
  </dd>
</dl>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l07313">7313</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="gab9a2402b9da984817b0de813562ea8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gab9a2402b9da984817b0de813562ea8b5">&#9670;&nbsp;</a></span>mpack_tree_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">MPACK_INLINE size_t mpack_tree_size </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size in bytes of the current parsed message.</p>
<p>If there is something in the buffer after the MessagePack object, this can be used to find it.</p>
<p>This is zero if an error occurred during tree parsing (since the portion of the data that the first complete object occupies cannot be determined if the data is invalid or corrupted.) </p>

<p class="definition">Definition at line <a class="el" href="mpack_8h_source.html#l07256">7256</a> of file <a class="el" href="mpack_8h_source.html">mpack.h</a>.</p>

</div>
</div>
<a id="ga9865c8548cfc3a53cbe82d682fc3e951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga9865c8548cfc3a53cbe82d682fc3e951">&#9670;&nbsp;</a></span>mpack_tree_try_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpack_tree_try_parse </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__node.html#ga9c76cfdb08042d6412b5c745bca928a7">mpack_tree_t</a> *&#160;</td>
          <td class="paramname"><em>tree</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Attempts to parse a MessagePack message from a non-blocking stream into a tree of immutable nodes.</p>
<p>A non-blocking read function must have been passed to the tree in <a class="el" href="group__node.html#ga3e42c40a9a8ae59d231e623d180a42d8">mpack_tree_init_stream()</a>.</p>
<p>If this returns true, a message is available under <a class="el" href="group__node.html#ga2c49262ce28699d5ec90db09b5fd2eee">mpack_tree_root()</a>. The tree nodes and data will be valid until the next time a parse is started.</p>
<p>If this returns false, no message is available, because either not enough data is available yet or an error has occurred. You must check the tree for errors whenever this returns false. If there is no error, you should try again later when more data is available. (You will want to select()/poll() on the underlying socket or use some other asynchronous mechanism to determine when it has data.)</p>
<p>There is no way to recover a tree in an error state. It must be destroyed.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="group__node.html#ga3e42c40a9a8ae59d231e623d180a42d8">mpack_tree_init_stream()</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div class="ttc" id="agroup__node_html_gada6980d1ebe8433ee525d8919ab179b0"><div class="ttname"><a href="group__node.html#gada6980d1ebe8433ee525d8919ab179b0">mpack_node_enum_optional</a></div><div class="ttdeci">size_t mpack_node_enum_optional(mpack_node_t node, const char *strings[], size_t count)</div></div>
<div class="ttc" id="agroup__node_html_ga38538087fb67888dfb77682580fb5086"><div class="ttname"><a href="group__node.html#ga38538087fb67888dfb77682580fb5086">mpack_node_enum</a></div><div class="ttdeci">size_t mpack_node_enum(mpack_node_t node, const char *strings[], size_t count)</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
